"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jss";
exports.ids = ["vendor-chunks/jss"];
exports.modules = {

/***/ "(ssr)/./node_modules/jss/dist/jss.esm.js":
/*!******************************************!*\
  !*** ./node_modules/jss/dist/jss.esm.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RuleList: () => (/* binding */ RuleList),\n/* harmony export */   SheetsManager: () => (/* binding */ SheetsManager),\n/* harmony export */   SheetsRegistry: () => (/* binding */ SheetsRegistry),\n/* harmony export */   create: () => (/* binding */ createJss),\n/* harmony export */   createGenerateId: () => (/* binding */ createGenerateId),\n/* harmony export */   createRule: () => (/* binding */ createRule),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   getDynamicStyles: () => (/* binding */ getDynamicStyles),\n/* harmony export */   hasCSSTOMSupport: () => (/* binding */ hasCSSTOMSupport),\n/* harmony export */   sheets: () => (/* binding */ sheets),\n/* harmony export */   toCssValue: () => (/* binding */ toCssValue)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var is_in_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! is-in-browser */ \"(ssr)/./node_modules/is-in-browser/dist/module.js\");\n/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! tiny-warning */ \"(ssr)/./node_modules/tiny-warning/dist/tiny-warning.esm.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inheritsLoose */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\");\n\n\n\n\n\n\n\nvar plainObjectConstrurctor = {}.constructor;\nfunction cloneStyle(style) {\n    if (style == null || typeof style !== \"object\") return style;\n    if (Array.isArray(style)) return style.map(cloneStyle);\n    if (style.constructor !== plainObjectConstrurctor) return style;\n    var newStyle = {};\n    for(var name in style){\n        newStyle[name] = cloneStyle(style[name]);\n    }\n    return newStyle;\n}\n/**\n * Create a rule instance.\n */ function createRule(name, decl, options) {\n    if (name === void 0) {\n        name = \"unnamed\";\n    }\n    var jss = options.jss;\n    var declCopy = cloneStyle(decl);\n    var rule = jss.plugins.onCreateRule(name, declCopy, options);\n    if (rule) return rule; // It is an at-rule and it has no instance.\n    if (name[0] === \"@\") {\n         true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(false, \"[JSS] Unknown rule \" + name) : 0;\n    }\n    return null;\n}\nvar join = function join(value, by) {\n    var result = \"\";\n    for(var i = 0; i < value.length; i++){\n        // Remove !important from the value, it will be readded later.\n        if (value[i] === \"!important\") break;\n        if (result) result += by;\n        result += value[i];\n    }\n    return result;\n};\n/**\n * Converts JSS array value to a CSS string.\n *\n * `margin: [['5px', '10px']]` > `margin: 5px 10px;`\n * `border: ['1px', '2px']` > `border: 1px, 2px;`\n * `margin: [['5px', '10px'], '!important']` > `margin: 5px 10px !important;`\n * `color: ['red', !important]` > `color: red !important;`\n */ var toCssValue = function toCssValue(value) {\n    if (!Array.isArray(value)) return value;\n    var cssValue = \"\"; // Support space separated values via `[['5px', '10px']]`.\n    if (Array.isArray(value[0])) {\n        for(var i = 0; i < value.length; i++){\n            if (value[i] === \"!important\") break;\n            if (cssValue) cssValue += \", \";\n            cssValue += join(value[i], \" \");\n        }\n    } else cssValue = join(value, \", \"); // Add !important, because it was ignored.\n    if (value[value.length - 1] === \"!important\") {\n        cssValue += \" !important\";\n    }\n    return cssValue;\n};\nfunction getWhitespaceSymbols(options) {\n    if (options && options.format === false) {\n        return {\n            linebreak: \"\",\n            space: \"\"\n        };\n    }\n    return {\n        linebreak: \"\\n\",\n        space: \" \"\n    };\n}\n/**\n * Indent a string.\n * http://jsperf.com/array-join-vs-for\n */ function indentStr(str, indent) {\n    var result = \"\";\n    for(var index = 0; index < indent; index++){\n        result += \"  \";\n    }\n    return result + str;\n}\n/**\n * Converts a Rule to CSS string.\n */ function toCss(selector, style, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var result = \"\";\n    if (!style) return result;\n    var _options = options, _options$indent = _options.indent, indent = _options$indent === void 0 ? 0 : _options$indent;\n    var fallbacks = style.fallbacks;\n    if (options.format === false) {\n        indent = -Infinity;\n    }\n    var _getWhitespaceSymbols = getWhitespaceSymbols(options), linebreak = _getWhitespaceSymbols.linebreak, space = _getWhitespaceSymbols.space;\n    if (selector) indent++; // Apply fallbacks first.\n    if (fallbacks) {\n        // Array syntax {fallbacks: [{prop: value}]}\n        if (Array.isArray(fallbacks)) {\n            for(var index = 0; index < fallbacks.length; index++){\n                var fallback = fallbacks[index];\n                for(var prop in fallback){\n                    var value = fallback[prop];\n                    if (value != null) {\n                        if (result) result += linebreak;\n                        result += indentStr(prop + \":\" + space + toCssValue(value) + \";\", indent);\n                    }\n                }\n            }\n        } else {\n            // Object syntax {fallbacks: {prop: value}}\n            for(var _prop in fallbacks){\n                var _value = fallbacks[_prop];\n                if (_value != null) {\n                    if (result) result += linebreak;\n                    result += indentStr(_prop + \":\" + space + toCssValue(_value) + \";\", indent);\n                }\n            }\n        }\n    }\n    for(var _prop2 in style){\n        var _value2 = style[_prop2];\n        if (_value2 != null && _prop2 !== \"fallbacks\") {\n            if (result) result += linebreak;\n            result += indentStr(_prop2 + \":\" + space + toCssValue(_value2) + \";\", indent);\n        }\n    } // Allow empty style in this case, because properties will be added dynamically.\n    if (!result && !options.allowEmpty) return result; // When rule is being stringified before selector was defined.\n    if (!selector) return result;\n    indent--;\n    if (result) result = \"\" + linebreak + result + linebreak;\n    return indentStr(\"\" + selector + space + \"{\" + result, indent) + indentStr(\"}\", indent);\n}\nvar escapeRegex = /([[\\].#*$><+~=|^:(),\"'`\\s])/g;\nvar nativeEscape = typeof CSS !== \"undefined\" && CSS.escape;\nvar escape = function(str) {\n    return nativeEscape ? nativeEscape(str) : str.replace(escapeRegex, \"\\\\$1\");\n};\nvar BaseStyleRule = /*#__PURE__*/ function() {\n    function BaseStyleRule(key, style, options) {\n        this.type = \"style\";\n        this.isProcessed = false;\n        var sheet = options.sheet, Renderer = options.Renderer;\n        this.key = key;\n        this.options = options;\n        this.style = style;\n        if (sheet) this.renderer = sheet.renderer;\n        else if (Renderer) this.renderer = new Renderer();\n    }\n    /**\n   * Get or set a style property.\n   */ var _proto = BaseStyleRule.prototype;\n    _proto.prop = function prop(name, value, options) {\n        // It's a getter.\n        if (value === undefined) return this.style[name]; // Don't do anything if the value has not changed.\n        var force = options ? options.force : false;\n        if (!force && this.style[name] === value) return this;\n        var newValue = value;\n        if (!options || options.process !== false) {\n            newValue = this.options.jss.plugins.onChangeValue(value, name, this);\n        }\n        var isEmpty = newValue == null || newValue === false;\n        var isDefined = name in this.style; // Value is empty and wasn't defined before.\n        if (isEmpty && !isDefined && !force) return this; // We are going to remove this value.\n        var remove = isEmpty && isDefined;\n        if (remove) delete this.style[name];\n        else this.style[name] = newValue; // Renderable is defined if StyleSheet option `link` is true.\n        if (this.renderable && this.renderer) {\n            if (remove) this.renderer.removeProperty(this.renderable, name);\n            else this.renderer.setProperty(this.renderable, name, newValue);\n            return this;\n        }\n        var sheet = this.options.sheet;\n        if (sheet && sheet.attached) {\n             true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(false, '[JSS] Rule is not linked. Missing sheet option \"link: true\".') : 0;\n        }\n        return this;\n    };\n    return BaseStyleRule;\n}();\nvar StyleRule = /*#__PURE__*/ function(_BaseStyleRule) {\n    (0,_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(StyleRule, _BaseStyleRule);\n    function StyleRule(key, style, options) {\n        var _this;\n        _this = _BaseStyleRule.call(this, key, style, options) || this;\n        var selector = options.selector, scoped = options.scoped, sheet = options.sheet, generateId = options.generateId;\n        if (selector) {\n            _this.selectorText = selector;\n        } else if (scoped !== false) {\n            _this.id = generateId((0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(_this)), sheet);\n            _this.selectorText = \".\" + escape(_this.id);\n        }\n        return _this;\n    }\n    /**\n   * Set selector string.\n   * Attention: use this with caution. Most browsers didn't implement\n   * selectorText setter, so this may result in rerendering of entire Style Sheet.\n   */ var _proto2 = StyleRule.prototype;\n    /**\n   * Apply rule to an element inline.\n   */ _proto2.applyTo = function applyTo(renderable) {\n        var renderer = this.renderer;\n        if (renderer) {\n            var json = this.toJSON();\n            for(var prop in json){\n                renderer.setProperty(renderable, prop, json[prop]);\n            }\n        }\n        return this;\n    } /**\n   * Returns JSON representation of the rule.\n   * Fallbacks are not supported.\n   * Useful for inline styles.\n   */ ;\n    _proto2.toJSON = function toJSON() {\n        var json = {};\n        for(var prop in this.style){\n            var value = this.style[prop];\n            if (typeof value !== \"object\") json[prop] = value;\n            else if (Array.isArray(value)) json[prop] = toCssValue(value);\n        }\n        return json;\n    } /**\n   * Generates a CSS string.\n   */ ;\n    _proto2.toString = function toString(options) {\n        var sheet = this.options.sheet;\n        var link = sheet ? sheet.options.link : false;\n        var opts = link ? (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, options, {\n            allowEmpty: true\n        }) : options;\n        return toCss(this.selectorText, this.style, opts);\n    };\n    (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(StyleRule, [\n        {\n            key: \"selector\",\n            set: function set(selector) {\n                if (selector === this.selectorText) return;\n                this.selectorText = selector;\n                var renderer = this.renderer, renderable = this.renderable;\n                if (!renderable || !renderer) return;\n                var hasChanged = renderer.setSelector(renderable, selector); // If selector setter is not implemented, rerender the rule.\n                if (!hasChanged) {\n                    renderer.replaceRule(renderable, this);\n                }\n            },\n            get: function get() {\n                return this.selectorText;\n            }\n        }\n    ]);\n    return StyleRule;\n}(BaseStyleRule);\nvar pluginStyleRule = {\n    onCreateRule: function onCreateRule(key, style, options) {\n        if (key[0] === \"@\" || options.parent && options.parent.type === \"keyframes\") {\n            return null;\n        }\n        return new StyleRule(key, style, options);\n    }\n};\nvar defaultToStringOptions = {\n    indent: 1,\n    children: true\n};\nvar atRegExp = /@([\\w-]+)/;\n/**\n * Conditional rule for @media, @supports\n */ var ConditionalRule = /*#__PURE__*/ function() {\n    function ConditionalRule(key, styles, options) {\n        this.type = \"conditional\";\n        this.isProcessed = false;\n        this.key = key;\n        var atMatch = key.match(atRegExp);\n        this.at = atMatch ? atMatch[1] : \"unknown\"; // Key might contain a unique suffix in case the `name` passed by user was duplicate.\n        this.query = options.name || \"@\" + this.at;\n        this.options = options;\n        this.rules = new RuleList((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, options, {\n            parent: this\n        }));\n        for(var name in styles){\n            this.rules.add(name, styles[name]);\n        }\n        this.rules.process();\n    }\n    /**\n   * Get a rule.\n   */ var _proto = ConditionalRule.prototype;\n    _proto.getRule = function getRule(name) {\n        return this.rules.get(name);\n    } /**\n   * Get index of a rule.\n   */ ;\n    _proto.indexOf = function indexOf(rule) {\n        return this.rules.indexOf(rule);\n    } /**\n   * Create and register rule, run plugins.\n   */ ;\n    _proto.addRule = function addRule(name, style, options) {\n        var rule = this.rules.add(name, style, options);\n        if (!rule) return null;\n        this.options.jss.plugins.onProcessRule(rule);\n        return rule;\n    } /**\n   * Replace rule, run plugins.\n   */ ;\n    _proto.replaceRule = function replaceRule(name, style, options) {\n        var newRule = this.rules.replace(name, style, options);\n        if (newRule) this.options.jss.plugins.onProcessRule(newRule);\n        return newRule;\n    } /**\n   * Generates a CSS string.\n   */ ;\n    _proto.toString = function toString(options) {\n        if (options === void 0) {\n            options = defaultToStringOptions;\n        }\n        var _getWhitespaceSymbols = getWhitespaceSymbols(options), linebreak = _getWhitespaceSymbols.linebreak;\n        if (options.indent == null) options.indent = defaultToStringOptions.indent;\n        if (options.children == null) options.children = defaultToStringOptions.children;\n        if (options.children === false) {\n            return this.query + \" {}\";\n        }\n        var children = this.rules.toString(options);\n        return children ? this.query + \" {\" + linebreak + children + linebreak + \"}\" : \"\";\n    };\n    return ConditionalRule;\n}();\nvar keyRegExp = /@container|@media|@supports\\s+/;\nvar pluginConditionalRule = {\n    onCreateRule: function onCreateRule(key, styles, options) {\n        return keyRegExp.test(key) ? new ConditionalRule(key, styles, options) : null;\n    }\n};\nvar defaultToStringOptions$1 = {\n    indent: 1,\n    children: true\n};\nvar nameRegExp = /@keyframes\\s+([\\w-]+)/;\n/**\n * Rule for @keyframes\n */ var KeyframesRule = /*#__PURE__*/ function() {\n    function KeyframesRule(key, frames, options) {\n        this.type = \"keyframes\";\n        this.at = \"@keyframes\";\n        this.isProcessed = false;\n        var nameMatch = key.match(nameRegExp);\n        if (nameMatch && nameMatch[1]) {\n            this.name = nameMatch[1];\n        } else {\n            this.name = \"noname\";\n             true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(false, \"[JSS] Bad keyframes name \" + key) : 0;\n        }\n        this.key = this.type + \"-\" + this.name;\n        this.options = options;\n        var scoped = options.scoped, sheet = options.sheet, generateId = options.generateId;\n        this.id = scoped === false ? this.name : escape(generateId(this, sheet));\n        this.rules = new RuleList((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, options, {\n            parent: this\n        }));\n        for(var name in frames){\n            this.rules.add(name, frames[name], (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, options, {\n                parent: this\n            }));\n        }\n        this.rules.process();\n    }\n    /**\n   * Generates a CSS string.\n   */ var _proto = KeyframesRule.prototype;\n    _proto.toString = function toString(options) {\n        if (options === void 0) {\n            options = defaultToStringOptions$1;\n        }\n        var _getWhitespaceSymbols = getWhitespaceSymbols(options), linebreak = _getWhitespaceSymbols.linebreak;\n        if (options.indent == null) options.indent = defaultToStringOptions$1.indent;\n        if (options.children == null) options.children = defaultToStringOptions$1.children;\n        if (options.children === false) {\n            return this.at + \" \" + this.id + \" {}\";\n        }\n        var children = this.rules.toString(options);\n        if (children) children = \"\" + linebreak + children + linebreak;\n        return this.at + \" \" + this.id + \" {\" + children + \"}\";\n    };\n    return KeyframesRule;\n}();\nvar keyRegExp$1 = /@keyframes\\s+/;\nvar refRegExp = /\\$([\\w-]+)/g;\nvar findReferencedKeyframe = function findReferencedKeyframe(val, keyframes) {\n    if (typeof val === \"string\") {\n        return val.replace(refRegExp, function(match, name) {\n            if (name in keyframes) {\n                return keyframes[name];\n            }\n             true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(false, '[JSS] Referenced keyframes rule \"' + name + '\" is not defined.') : 0;\n            return match;\n        });\n    }\n    return val;\n};\n/**\n * Replace the reference for a animation name.\n */ var replaceRef = function replaceRef(style, prop, keyframes) {\n    var value = style[prop];\n    var refKeyframe = findReferencedKeyframe(value, keyframes);\n    if (refKeyframe !== value) {\n        style[prop] = refKeyframe;\n    }\n};\nvar pluginKeyframesRule = {\n    onCreateRule: function onCreateRule(key, frames, options) {\n        return typeof key === \"string\" && keyRegExp$1.test(key) ? new KeyframesRule(key, frames, options) : null;\n    },\n    // Animation name ref replacer.\n    onProcessStyle: function onProcessStyle(style, rule, sheet) {\n        if (rule.type !== \"style\" || !sheet) return style;\n        if (\"animation-name\" in style) replaceRef(style, \"animation-name\", sheet.keyframes);\n        if (\"animation\" in style) replaceRef(style, \"animation\", sheet.keyframes);\n        return style;\n    },\n    onChangeValue: function onChangeValue(val, prop, rule) {\n        var sheet = rule.options.sheet;\n        if (!sheet) {\n            return val;\n        }\n        switch(prop){\n            case \"animation\":\n                return findReferencedKeyframe(val, sheet.keyframes);\n            case \"animation-name\":\n                return findReferencedKeyframe(val, sheet.keyframes);\n            default:\n                return val;\n        }\n    }\n};\nvar KeyframeRule = /*#__PURE__*/ function(_BaseStyleRule) {\n    (0,_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(KeyframeRule, _BaseStyleRule);\n    function KeyframeRule() {\n        return _BaseStyleRule.apply(this, arguments) || this;\n    }\n    var _proto = KeyframeRule.prototype;\n    /**\n   * Generates a CSS string.\n   */ _proto.toString = function toString(options) {\n        var sheet = this.options.sheet;\n        var link = sheet ? sheet.options.link : false;\n        var opts = link ? (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, options, {\n            allowEmpty: true\n        }) : options;\n        return toCss(this.key, this.style, opts);\n    };\n    return KeyframeRule;\n}(BaseStyleRule);\nvar pluginKeyframeRule = {\n    onCreateRule: function onCreateRule(key, style, options) {\n        if (options.parent && options.parent.type === \"keyframes\") {\n            return new KeyframeRule(key, style, options);\n        }\n        return null;\n    }\n};\nvar FontFaceRule = /*#__PURE__*/ function() {\n    function FontFaceRule(key, style, options) {\n        this.type = \"font-face\";\n        this.at = \"@font-face\";\n        this.isProcessed = false;\n        this.key = key;\n        this.style = style;\n        this.options = options;\n    }\n    /**\n   * Generates a CSS string.\n   */ var _proto = FontFaceRule.prototype;\n    _proto.toString = function toString(options) {\n        var _getWhitespaceSymbols = getWhitespaceSymbols(options), linebreak = _getWhitespaceSymbols.linebreak;\n        if (Array.isArray(this.style)) {\n            var str = \"\";\n            for(var index = 0; index < this.style.length; index++){\n                str += toCss(this.at, this.style[index]);\n                if (this.style[index + 1]) str += linebreak;\n            }\n            return str;\n        }\n        return toCss(this.at, this.style, options);\n    };\n    return FontFaceRule;\n}();\nvar keyRegExp$2 = /@font-face/;\nvar pluginFontFaceRule = {\n    onCreateRule: function onCreateRule(key, style, options) {\n        return keyRegExp$2.test(key) ? new FontFaceRule(key, style, options) : null;\n    }\n};\nvar ViewportRule = /*#__PURE__*/ function() {\n    function ViewportRule(key, style, options) {\n        this.type = \"viewport\";\n        this.at = \"@viewport\";\n        this.isProcessed = false;\n        this.key = key;\n        this.style = style;\n        this.options = options;\n    }\n    /**\n   * Generates a CSS string.\n   */ var _proto = ViewportRule.prototype;\n    _proto.toString = function toString(options) {\n        return toCss(this.key, this.style, options);\n    };\n    return ViewportRule;\n}();\nvar pluginViewportRule = {\n    onCreateRule: function onCreateRule(key, style, options) {\n        return key === \"@viewport\" || key === \"@-ms-viewport\" ? new ViewportRule(key, style, options) : null;\n    }\n};\nvar SimpleRule = /*#__PURE__*/ function() {\n    function SimpleRule(key, value, options) {\n        this.type = \"simple\";\n        this.isProcessed = false;\n        this.key = key;\n        this.value = value;\n        this.options = options;\n    }\n    /**\n   * Generates a CSS string.\n   */ // eslint-disable-next-line no-unused-vars\n    var _proto = SimpleRule.prototype;\n    _proto.toString = function toString(options) {\n        if (Array.isArray(this.value)) {\n            var str = \"\";\n            for(var index = 0; index < this.value.length; index++){\n                str += this.key + \" \" + this.value[index] + \";\";\n                if (this.value[index + 1]) str += \"\\n\";\n            }\n            return str;\n        }\n        return this.key + \" \" + this.value + \";\";\n    };\n    return SimpleRule;\n}();\nvar keysMap = {\n    \"@charset\": true,\n    \"@import\": true,\n    \"@namespace\": true\n};\nvar pluginSimpleRule = {\n    onCreateRule: function onCreateRule(key, value, options) {\n        return key in keysMap ? new SimpleRule(key, value, options) : null;\n    }\n};\nvar plugins = [\n    pluginStyleRule,\n    pluginConditionalRule,\n    pluginKeyframesRule,\n    pluginKeyframeRule,\n    pluginFontFaceRule,\n    pluginViewportRule,\n    pluginSimpleRule\n];\nvar defaultUpdateOptions = {\n    process: true\n};\nvar forceUpdateOptions = {\n    force: true,\n    process: true\n};\nvar RuleList = /*#__PURE__*/ function() {\n    // Rules registry for access by .get() method.\n    // It contains the same rule registered by name and by selector.\n    // Original styles object.\n    // Used to ensure correct rules order.\n    function RuleList(options) {\n        this.map = {};\n        this.raw = {};\n        this.index = [];\n        this.counter = 0;\n        this.options = options;\n        this.classes = options.classes;\n        this.keyframes = options.keyframes;\n    }\n    /**\n   * Create and register rule.\n   *\n   * Will not render after Style Sheet was rendered the first time.\n   */ var _proto = RuleList.prototype;\n    _proto.add = function add(name, decl, ruleOptions) {\n        var _this$options = this.options, parent = _this$options.parent, sheet = _this$options.sheet, jss = _this$options.jss, Renderer = _this$options.Renderer, generateId = _this$options.generateId, scoped = _this$options.scoped;\n        var options = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n            classes: this.classes,\n            parent: parent,\n            sheet: sheet,\n            jss: jss,\n            Renderer: Renderer,\n            generateId: generateId,\n            scoped: scoped,\n            name: name,\n            keyframes: this.keyframes,\n            selector: undefined\n        }, ruleOptions); // When user uses .createStyleSheet(), duplicate names are not possible, but\n        // `sheet.addRule()` opens the door for any duplicate rule name. When this happens\n        // we need to make the key unique within this RuleList instance scope.\n        var key = name;\n        if (name in this.raw) {\n            key = name + \"-d\" + this.counter++;\n        } // We need to save the original decl before creating the rule\n        // because cache plugin needs to use it as a key to return a cached rule.\n        this.raw[key] = decl;\n        if (key in this.classes) {\n            // E.g. rules inside of @media container\n            options.selector = \".\" + escape(this.classes[key]);\n        }\n        var rule = createRule(key, decl, options);\n        if (!rule) return null;\n        this.register(rule);\n        var index = options.index === undefined ? this.index.length : options.index;\n        this.index.splice(index, 0, rule);\n        return rule;\n    } /**\n   * Replace rule.\n   * Create a new rule and remove old one instead of overwriting\n   * because we want to invoke onCreateRule hook to make plugins work.\n   */ ;\n    _proto.replace = function replace(name, decl, ruleOptions) {\n        var oldRule = this.get(name);\n        var oldIndex = this.index.indexOf(oldRule);\n        if (oldRule) {\n            this.remove(oldRule);\n        }\n        var options = ruleOptions;\n        if (oldIndex !== -1) options = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, ruleOptions, {\n            index: oldIndex\n        });\n        return this.add(name, decl, options);\n    } /**\n   * Get a rule by name or selector.\n   */ ;\n    _proto.get = function get(nameOrSelector) {\n        return this.map[nameOrSelector];\n    } /**\n   * Delete a rule.\n   */ ;\n    _proto.remove = function remove(rule) {\n        this.unregister(rule);\n        delete this.raw[rule.key];\n        this.index.splice(this.index.indexOf(rule), 1);\n    } /**\n   * Get index of a rule.\n   */ ;\n    _proto.indexOf = function indexOf(rule) {\n        return this.index.indexOf(rule);\n    } /**\n   * Run `onProcessRule()` plugins on every rule.\n   */ ;\n    _proto.process = function process() {\n        var plugins = this.options.jss.plugins; // We need to clone array because if we modify the index somewhere else during a loop\n        // we end up with very hard-to-track-down side effects.\n        this.index.slice(0).forEach(plugins.onProcessRule, plugins);\n    } /**\n   * Register a rule in `.map`, `.classes` and `.keyframes` maps.\n   */ ;\n    _proto.register = function register(rule) {\n        this.map[rule.key] = rule;\n        if (rule instanceof StyleRule) {\n            this.map[rule.selector] = rule;\n            if (rule.id) this.classes[rule.key] = rule.id;\n        } else if (rule instanceof KeyframesRule && this.keyframes) {\n            this.keyframes[rule.name] = rule.id;\n        }\n    } /**\n   * Unregister a rule.\n   */ ;\n    _proto.unregister = function unregister(rule) {\n        delete this.map[rule.key];\n        if (rule instanceof StyleRule) {\n            delete this.map[rule.selector];\n            delete this.classes[rule.key];\n        } else if (rule instanceof KeyframesRule) {\n            delete this.keyframes[rule.name];\n        }\n    } /**\n   * Update the function values with a new data.\n   */ ;\n    _proto.update = function update() {\n        var name;\n        var data;\n        var options;\n        if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === \"string\") {\n            name = arguments.length <= 0 ? undefined : arguments[0];\n            data = arguments.length <= 1 ? undefined : arguments[1];\n            options = arguments.length <= 2 ? undefined : arguments[2];\n        } else {\n            data = arguments.length <= 0 ? undefined : arguments[0];\n            options = arguments.length <= 1 ? undefined : arguments[1];\n            name = null;\n        }\n        if (name) {\n            this.updateOne(this.get(name), data, options);\n        } else {\n            for(var index = 0; index < this.index.length; index++){\n                this.updateOne(this.index[index], data, options);\n            }\n        }\n    } /**\n   * Execute plugins, update rule props.\n   */ ;\n    _proto.updateOne = function updateOne(rule, data, options) {\n        if (options === void 0) {\n            options = defaultUpdateOptions;\n        }\n        var _this$options2 = this.options, plugins = _this$options2.jss.plugins, sheet = _this$options2.sheet; // It is a rules container like for e.g. ConditionalRule.\n        if (rule.rules instanceof RuleList) {\n            rule.rules.update(data, options);\n            return;\n        }\n        var style = rule.style;\n        plugins.onUpdate(data, rule, sheet, options); // We rely on a new `style` ref in case it was mutated during onUpdate hook.\n        if (options.process && style && style !== rule.style) {\n            // We need to run the plugins in case new `style` relies on syntax plugins.\n            plugins.onProcessStyle(rule.style, rule, sheet); // Update and add props.\n            for(var prop in rule.style){\n                var nextValue = rule.style[prop];\n                var prevValue = style[prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.\n                // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.\n                if (nextValue !== prevValue) {\n                    rule.prop(prop, nextValue, forceUpdateOptions);\n                }\n            } // Remove props.\n            for(var _prop in style){\n                var _nextValue = rule.style[_prop];\n                var _prevValue = style[_prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.\n                // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.\n                if (_nextValue == null && _nextValue !== _prevValue) {\n                    rule.prop(_prop, null, forceUpdateOptions);\n                }\n            }\n        }\n    } /**\n   * Convert rules to a CSS string.\n   */ ;\n    _proto.toString = function toString(options) {\n        var str = \"\";\n        var sheet = this.options.sheet;\n        var link = sheet ? sheet.options.link : false;\n        var _getWhitespaceSymbols = getWhitespaceSymbols(options), linebreak = _getWhitespaceSymbols.linebreak;\n        for(var index = 0; index < this.index.length; index++){\n            var rule = this.index[index];\n            var css = rule.toString(options); // No need to render an empty rule.\n            if (!css && !link) continue;\n            if (str) str += linebreak;\n            str += css;\n        }\n        return str;\n    };\n    return RuleList;\n}();\nvar StyleSheet = /*#__PURE__*/ function() {\n    function StyleSheet(styles, options) {\n        this.attached = false;\n        this.deployed = false;\n        this.classes = {};\n        this.keyframes = {};\n        this.options = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, options, {\n            sheet: this,\n            parent: this,\n            classes: this.classes,\n            keyframes: this.keyframes\n        });\n        if (options.Renderer) {\n            this.renderer = new options.Renderer(this);\n        }\n        this.rules = new RuleList(this.options);\n        for(var name in styles){\n            this.rules.add(name, styles[name]);\n        }\n        this.rules.process();\n    }\n    /**\n   * Attach renderable to the render tree.\n   */ var _proto = StyleSheet.prototype;\n    _proto.attach = function attach() {\n        if (this.attached) return this;\n        if (this.renderer) this.renderer.attach();\n        this.attached = true; // Order is important, because we can't use insertRule API if style element is not attached.\n        if (!this.deployed) this.deploy();\n        return this;\n    } /**\n   * Remove renderable from render tree.\n   */ ;\n    _proto.detach = function detach() {\n        if (!this.attached) return this;\n        if (this.renderer) this.renderer.detach();\n        this.attached = false;\n        return this;\n    } /**\n   * Add a rule to the current stylesheet.\n   * Will insert a rule also after the stylesheet has been rendered first time.\n   */ ;\n    _proto.addRule = function addRule(name, decl, options) {\n        var queue = this.queue; // Plugins can create rules.\n        // In order to preserve the right order, we need to queue all `.addRule` calls,\n        // which happen after the first `rules.add()` call.\n        if (this.attached && !queue) this.queue = [];\n        var rule = this.rules.add(name, decl, options);\n        if (!rule) return null;\n        this.options.jss.plugins.onProcessRule(rule);\n        if (this.attached) {\n            if (!this.deployed) return rule; // Don't insert rule directly if there is no stringified version yet.\n            // It will be inserted all together when .attach is called.\n            if (queue) queue.push(rule);\n            else {\n                this.insertRule(rule);\n                if (this.queue) {\n                    this.queue.forEach(this.insertRule, this);\n                    this.queue = undefined;\n                }\n            }\n            return rule;\n        } // We can't add rules to a detached style node.\n        // We will redeploy the sheet once user will attach it.\n        this.deployed = false;\n        return rule;\n    } /**\n   * Replace a rule in the current stylesheet.\n   */ ;\n    _proto.replaceRule = function replaceRule(nameOrSelector, decl, options) {\n        var oldRule = this.rules.get(nameOrSelector);\n        if (!oldRule) return this.addRule(nameOrSelector, decl, options);\n        var newRule = this.rules.replace(nameOrSelector, decl, options);\n        if (newRule) {\n            this.options.jss.plugins.onProcessRule(newRule);\n        }\n        if (this.attached) {\n            if (!this.deployed) return newRule; // Don't replace / delete rule directly if there is no stringified version yet.\n            // It will be inserted all together when .attach is called.\n            if (this.renderer) {\n                if (!newRule) {\n                    this.renderer.deleteRule(oldRule);\n                } else if (oldRule.renderable) {\n                    this.renderer.replaceRule(oldRule.renderable, newRule);\n                }\n            }\n            return newRule;\n        } // We can't replace rules to a detached style node.\n        // We will redeploy the sheet once user will attach it.\n        this.deployed = false;\n        return newRule;\n    } /**\n   * Insert rule into the StyleSheet\n   */ ;\n    _proto.insertRule = function insertRule(rule) {\n        if (this.renderer) {\n            this.renderer.insertRule(rule);\n        }\n    } /**\n   * Create and add rules.\n   * Will render also after Style Sheet was rendered the first time.\n   */ ;\n    _proto.addRules = function addRules(styles, options) {\n        var added = [];\n        for(var name in styles){\n            var rule = this.addRule(name, styles[name], options);\n            if (rule) added.push(rule);\n        }\n        return added;\n    } /**\n   * Get a rule by name or selector.\n   */ ;\n    _proto.getRule = function getRule(nameOrSelector) {\n        return this.rules.get(nameOrSelector);\n    } /**\n   * Delete a rule by name.\n   * Returns `true`: if rule has been deleted from the DOM.\n   */ ;\n    _proto.deleteRule = function deleteRule(name) {\n        var rule = typeof name === \"object\" ? name : this.rules.get(name);\n        if (!rule || // Style sheet was created without link: true and attached, in this case we\n        // won't be able to remove the CSS rule from the DOM.\n        this.attached && !rule.renderable) {\n            return false;\n        }\n        this.rules.remove(rule);\n        if (this.attached && rule.renderable && this.renderer) {\n            return this.renderer.deleteRule(rule.renderable);\n        }\n        return true;\n    } /**\n   * Get index of a rule.\n   */ ;\n    _proto.indexOf = function indexOf(rule) {\n        return this.rules.indexOf(rule);\n    } /**\n   * Deploy pure CSS string to a renderable.\n   */ ;\n    _proto.deploy = function deploy() {\n        if (this.renderer) this.renderer.deploy();\n        this.deployed = true;\n        return this;\n    } /**\n   * Update the function values with a new data.\n   */ ;\n    _proto.update = function update() {\n        var _this$rules;\n        (_this$rules = this.rules).update.apply(_this$rules, arguments);\n        return this;\n    } /**\n   * Updates a single rule.\n   */ ;\n    _proto.updateOne = function updateOne(rule, data, options) {\n        this.rules.updateOne(rule, data, options);\n        return this;\n    } /**\n   * Convert rules to a CSS string.\n   */ ;\n    _proto.toString = function toString(options) {\n        return this.rules.toString(options);\n    };\n    return StyleSheet;\n}();\nvar PluginsRegistry = /*#__PURE__*/ function() {\n    function PluginsRegistry() {\n        this.plugins = {\n            internal: [],\n            external: []\n        };\n        this.registry = {};\n    }\n    var _proto = PluginsRegistry.prototype;\n    /**\n   * Call `onCreateRule` hooks and return an object if returned by a hook.\n   */ _proto.onCreateRule = function onCreateRule(name, decl, options) {\n        for(var i = 0; i < this.registry.onCreateRule.length; i++){\n            var rule = this.registry.onCreateRule[i](name, decl, options);\n            if (rule) return rule;\n        }\n        return null;\n    } /**\n   * Call `onProcessRule` hooks.\n   */ ;\n    _proto.onProcessRule = function onProcessRule(rule) {\n        if (rule.isProcessed) return;\n        var sheet = rule.options.sheet;\n        for(var i = 0; i < this.registry.onProcessRule.length; i++){\n            this.registry.onProcessRule[i](rule, sheet);\n        }\n        if (rule.style) this.onProcessStyle(rule.style, rule, sheet);\n        rule.isProcessed = true;\n    } /**\n   * Call `onProcessStyle` hooks.\n   */ ;\n    _proto.onProcessStyle = function onProcessStyle(style, rule, sheet) {\n        for(var i = 0; i < this.registry.onProcessStyle.length; i++){\n            rule.style = this.registry.onProcessStyle[i](rule.style, rule, sheet);\n        }\n    } /**\n   * Call `onProcessSheet` hooks.\n   */ ;\n    _proto.onProcessSheet = function onProcessSheet(sheet) {\n        for(var i = 0; i < this.registry.onProcessSheet.length; i++){\n            this.registry.onProcessSheet[i](sheet);\n        }\n    } /**\n   * Call `onUpdate` hooks.\n   */ ;\n    _proto.onUpdate = function onUpdate(data, rule, sheet, options) {\n        for(var i = 0; i < this.registry.onUpdate.length; i++){\n            this.registry.onUpdate[i](data, rule, sheet, options);\n        }\n    } /**\n   * Call `onChangeValue` hooks.\n   */ ;\n    _proto.onChangeValue = function onChangeValue(value, prop, rule) {\n        var processedValue = value;\n        for(var i = 0; i < this.registry.onChangeValue.length; i++){\n            processedValue = this.registry.onChangeValue[i](processedValue, prop, rule);\n        }\n        return processedValue;\n    } /**\n   * Register a plugin.\n   */ ;\n    _proto.use = function use(newPlugin, options) {\n        if (options === void 0) {\n            options = {\n                queue: \"external\"\n            };\n        }\n        var plugins = this.plugins[options.queue]; // Avoids applying same plugin twice, at least based on ref.\n        if (plugins.indexOf(newPlugin) !== -1) {\n            return;\n        }\n        plugins.push(newPlugin);\n        this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function(registry, plugin) {\n            for(var name in plugin){\n                if (name in registry) {\n                    registry[name].push(plugin[name]);\n                } else {\n                     true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(false, '[JSS] Unknown hook \"' + name + '\".') : 0;\n                }\n            }\n            return registry;\n        }, {\n            onCreateRule: [],\n            onProcessRule: [],\n            onProcessStyle: [],\n            onProcessSheet: [],\n            onChangeValue: [],\n            onUpdate: []\n        });\n    };\n    return PluginsRegistry;\n}();\n/**\n * Sheets registry to access all instances in one place.\n */ var SheetsRegistry = /*#__PURE__*/ function() {\n    function SheetsRegistry() {\n        this.registry = [];\n    }\n    var _proto = SheetsRegistry.prototype;\n    /**\n   * Register a Style Sheet.\n   */ _proto.add = function add(sheet) {\n        var registry = this.registry;\n        var index = sheet.options.index;\n        if (registry.indexOf(sheet) !== -1) return;\n        if (registry.length === 0 || index >= this.index) {\n            registry.push(sheet);\n            return;\n        } // Find a position.\n        for(var i = 0; i < registry.length; i++){\n            if (registry[i].options.index > index) {\n                registry.splice(i, 0, sheet);\n                return;\n            }\n        }\n    } /**\n   * Reset the registry.\n   */ ;\n    _proto.reset = function reset() {\n        this.registry = [];\n    } /**\n   * Remove a Style Sheet.\n   */ ;\n    _proto.remove = function remove(sheet) {\n        var index = this.registry.indexOf(sheet);\n        this.registry.splice(index, 1);\n    } /**\n   * Convert all attached sheets to a CSS string.\n   */ ;\n    _proto.toString = function toString(_temp) {\n        var _ref = _temp === void 0 ? {} : _temp, attached = _ref.attached, options = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(_ref, [\n            \"attached\"\n        ]);\n        var _getWhitespaceSymbols = getWhitespaceSymbols(options), linebreak = _getWhitespaceSymbols.linebreak;\n        var css = \"\";\n        for(var i = 0; i < this.registry.length; i++){\n            var sheet = this.registry[i];\n            if (attached != null && sheet.attached !== attached) {\n                continue;\n            }\n            if (css) css += linebreak;\n            css += sheet.toString(options);\n        }\n        return css;\n    };\n    (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(SheetsRegistry, [\n        {\n            key: \"index\",\n            /**\n     * Current highest index number.\n     */ get: function get() {\n                return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;\n            }\n        }\n    ]);\n    return SheetsRegistry;\n}();\n/**\n * This is a global sheets registry. Only DomRenderer will add sheets to it.\n * On the server one should use an own SheetsRegistry instance and add the\n * sheets to it, because you need to make sure to create a new registry for\n * each request in order to not leak sheets across requests.\n */ var sheets = new SheetsRegistry();\n/* eslint-disable */ /**\n * Now that `globalThis` is available on most platforms\n * (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis#browser_compatibility)\n * we check for `globalThis` first. `globalThis` is necessary for jss\n * to run in Agoric's secure version of JavaScript (SES). Under SES,\n * `globalThis` exists, but `window`, `self`, and `Function('return\n * this')()` are all undefined for security reasons.\n *\n * https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n */ var globalThis$1 = typeof globalThis !== \"undefined\" ? globalThis :  false ? 0 : typeof self !== \"undefined\" && self.Math === Math ? self : Function(\"return this\")();\nvar ns = \"2f1acc6c3a606b082e5eef5e54414ffb\";\nif (globalThis$1[ns] == null) globalThis$1[ns] = 0; // Bundle may contain multiple JSS versions at the same time. In order to identify\n// the current version with just one short number and use it for classes generation\n// we use a counter. Also it is more accurate, because user can manually reevaluate\n// the module.\nvar moduleId = globalThis$1[ns]++;\nvar maxRules = 1e10;\n/**\n * Returns a function which generates unique class names based on counters.\n * When new generator function is created, rule counter is reseted.\n * We need to reset the rule counter for SSR for each request.\n */ var createGenerateId = function createGenerateId(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var ruleCounter = 0;\n    var generateId = function generateId(rule, sheet) {\n        ruleCounter += 1;\n        if (ruleCounter > maxRules) {\n             true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(false, \"[JSS] You might have a memory leak. Rule counter is at \" + ruleCounter + \".\") : 0;\n        }\n        var jssId = \"\";\n        var prefix = \"\";\n        if (sheet) {\n            if (sheet.options.classNamePrefix) {\n                prefix = sheet.options.classNamePrefix;\n            }\n            if (sheet.options.jss.id != null) {\n                jssId = String(sheet.options.jss.id);\n            }\n        }\n        if (options.minify) {\n            // Using \"c\" because a number can't be the first char in a class name.\n            return \"\" + (prefix || \"c\") + moduleId + jssId + ruleCounter;\n        }\n        return prefix + rule.key + \"-\" + moduleId + (jssId ? \"-\" + jssId : \"\") + \"-\" + ruleCounter;\n    };\n    return generateId;\n};\n/**\n * Cache the value from the first time a function is called.\n */ var memoize = function memoize(fn) {\n    var value;\n    return function() {\n        if (!value) value = fn();\n        return value;\n    };\n};\n/**\n * Get a style property value.\n */ var getPropertyValue = function getPropertyValue(cssRule, prop) {\n    try {\n        // Support CSSTOM.\n        if (cssRule.attributeStyleMap) {\n            return cssRule.attributeStyleMap.get(prop);\n        }\n        return cssRule.style.getPropertyValue(prop);\n    } catch (err) {\n        // IE may throw if property is unknown.\n        return \"\";\n    }\n};\n/**\n * Set a style property.\n */ var setProperty = function setProperty(cssRule, prop, value) {\n    try {\n        var cssValue = value;\n        if (Array.isArray(value)) {\n            cssValue = toCssValue(value);\n        } // Support CSSTOM.\n        if (cssRule.attributeStyleMap) {\n            cssRule.attributeStyleMap.set(prop, cssValue);\n        } else {\n            var indexOfImportantFlag = cssValue ? cssValue.indexOf(\"!important\") : -1;\n            var cssValueWithoutImportantFlag = indexOfImportantFlag > -1 ? cssValue.substr(0, indexOfImportantFlag - 1) : cssValue;\n            cssRule.style.setProperty(prop, cssValueWithoutImportantFlag, indexOfImportantFlag > -1 ? \"important\" : \"\");\n        }\n    } catch (err) {\n        // IE may throw if property is unknown.\n        return false;\n    }\n    return true;\n};\n/**\n * Remove a style property.\n */ var removeProperty = function removeProperty(cssRule, prop) {\n    try {\n        // Support CSSTOM.\n        if (cssRule.attributeStyleMap) {\n            cssRule.attributeStyleMap.delete(prop);\n        } else {\n            cssRule.style.removeProperty(prop);\n        }\n    } catch (err) {\n         true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(false, '[JSS] DOMException \"' + err.message + '\" was thrown. Tried to remove property \"' + prop + '\".') : 0;\n    }\n};\n/**\n * Set the selector.\n */ var setSelector = function setSelector(cssRule, selectorText) {\n    cssRule.selectorText = selectorText; // Return false if setter was not successful.\n    // Currently works in chrome only.\n    return cssRule.selectorText === selectorText;\n};\n/**\n * Gets the `head` element upon the first call and caches it.\n * We assume it can't be null.\n */ var getHead = memoize(function() {\n    return document.querySelector(\"head\");\n});\n/**\n * Find attached sheet with an index higher than the passed one.\n */ function findHigherSheet(registry, options) {\n    for(var i = 0; i < registry.length; i++){\n        var sheet = registry[i];\n        if (sheet.attached && sheet.options.index > options.index && sheet.options.insertionPoint === options.insertionPoint) {\n            return sheet;\n        }\n    }\n    return null;\n}\n/**\n * Find attached sheet with the highest index.\n */ function findHighestSheet(registry, options) {\n    for(var i = registry.length - 1; i >= 0; i--){\n        var sheet = registry[i];\n        if (sheet.attached && sheet.options.insertionPoint === options.insertionPoint) {\n            return sheet;\n        }\n    }\n    return null;\n}\n/**\n * Find a comment with \"jss\" inside.\n */ function findCommentNode(text) {\n    var head = getHead();\n    for(var i = 0; i < head.childNodes.length; i++){\n        var node = head.childNodes[i];\n        if (node.nodeType === 8 && node.nodeValue.trim() === text) {\n            return node;\n        }\n    }\n    return null;\n}\n/**\n * Find a node before which we can insert the sheet.\n */ function findPrevNode(options) {\n    var registry = sheets.registry;\n    if (registry.length > 0) {\n        // Try to insert before the next higher sheet.\n        var sheet = findHigherSheet(registry, options);\n        if (sheet && sheet.renderer) {\n            return {\n                parent: sheet.renderer.element.parentNode,\n                node: sheet.renderer.element\n            };\n        } // Otherwise insert after the last attached.\n        sheet = findHighestSheet(registry, options);\n        if (sheet && sheet.renderer) {\n            return {\n                parent: sheet.renderer.element.parentNode,\n                node: sheet.renderer.element.nextSibling\n            };\n        }\n    } // Try to find a comment placeholder if registry is empty.\n    var insertionPoint = options.insertionPoint;\n    if (insertionPoint && typeof insertionPoint === \"string\") {\n        var comment = findCommentNode(insertionPoint);\n        if (comment) {\n            return {\n                parent: comment.parentNode,\n                node: comment.nextSibling\n            };\n        } // If user specifies an insertion point and it can't be found in the document -\n        // bad specificity issues may appear.\n         true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(false, '[JSS] Insertion point \"' + insertionPoint + '\" not found.') : 0;\n    }\n    return false;\n}\n/**\n * Insert style element into the DOM.\n */ function insertStyle(style, options) {\n    var insertionPoint = options.insertionPoint;\n    var nextNode = findPrevNode(options);\n    if (nextNode !== false && nextNode.parent) {\n        nextNode.parent.insertBefore(style, nextNode.node);\n        return;\n    } // Works with iframes and any node types.\n    if (insertionPoint && typeof insertionPoint.nodeType === \"number\") {\n        var insertionPointElement = insertionPoint;\n        var parentNode = insertionPointElement.parentNode;\n        if (parentNode) parentNode.insertBefore(style, insertionPointElement.nextSibling);\n        else  true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(false, \"[JSS] Insertion point is not in the DOM.\") : 0;\n        return;\n    }\n    getHead().appendChild(style);\n}\n/**\n * Read jss nonce setting from the page if the user has set it.\n */ var getNonce = memoize(function() {\n    var node = document.querySelector('meta[property=\"csp-nonce\"]');\n    return node ? node.getAttribute(\"content\") : null;\n});\nvar _insertRule = function insertRule(container, rule, index) {\n    try {\n        if (\"insertRule\" in container) {\n            container.insertRule(rule, index);\n        } else if (\"appendRule\" in container) {\n            container.appendRule(rule);\n        }\n    } catch (err) {\n         true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(false, \"[JSS] \" + err.message) : 0;\n        return false;\n    }\n    return container.cssRules[index];\n};\nvar getValidRuleInsertionIndex = function getValidRuleInsertionIndex(container, index) {\n    var maxIndex = container.cssRules.length; // In case previous insertion fails, passed index might be wrong\n    if (index === undefined || index > maxIndex) {\n        // eslint-disable-next-line no-param-reassign\n        return maxIndex;\n    }\n    return index;\n};\nvar createStyle = function createStyle() {\n    var el = document.createElement(\"style\"); // Without it, IE will have a broken source order specificity if we\n    // insert rules after we insert the style tag.\n    // It seems to kick-off the source order specificity algorithm.\n    el.textContent = \"\\n\";\n    return el;\n};\nvar DomRenderer = /*#__PURE__*/ function() {\n    // Will be empty if link: true option is not set, because\n    // it is only for use together with insertRule API.\n    function DomRenderer(sheet) {\n        this.getPropertyValue = getPropertyValue;\n        this.setProperty = setProperty;\n        this.removeProperty = removeProperty;\n        this.setSelector = setSelector;\n        this.hasInsertedRules = false;\n        this.cssRules = [];\n        // There is no sheet when the renderer is used from a standalone StyleRule.\n        if (sheet) sheets.add(sheet);\n        this.sheet = sheet;\n        var _ref = this.sheet ? this.sheet.options : {}, media = _ref.media, meta = _ref.meta, element = _ref.element;\n        this.element = element || createStyle();\n        this.element.setAttribute(\"data-jss\", \"\");\n        if (media) this.element.setAttribute(\"media\", media);\n        if (meta) this.element.setAttribute(\"data-meta\", meta);\n        var nonce = getNonce();\n        if (nonce) this.element.setAttribute(\"nonce\", nonce);\n    }\n    /**\n   * Insert style element into render tree.\n   */ var _proto = DomRenderer.prototype;\n    _proto.attach = function attach() {\n        // In the case the element node is external and it is already in the DOM.\n        if (this.element.parentNode || !this.sheet) return;\n        insertStyle(this.element, this.sheet.options); // When rules are inserted using `insertRule` API, after `sheet.detach().attach()`\n        // most browsers create a new CSSStyleSheet, except of all IEs.\n        var deployed = Boolean(this.sheet && this.sheet.deployed);\n        if (this.hasInsertedRules && deployed) {\n            this.hasInsertedRules = false;\n            this.deploy();\n        }\n    } /**\n   * Remove style element from render tree.\n   */ ;\n    _proto.detach = function detach() {\n        if (!this.sheet) return;\n        var parentNode = this.element.parentNode;\n        if (parentNode) parentNode.removeChild(this.element); // In the most browsers, rules inserted using insertRule() API will be lost when style element is removed.\n        // Though IE will keep them and we need a consistent behavior.\n        if (this.sheet.options.link) {\n            this.cssRules = [];\n            this.element.textContent = \"\\n\";\n        }\n    } /**\n   * Inject CSS string into element.\n   */ ;\n    _proto.deploy = function deploy() {\n        var sheet = this.sheet;\n        if (!sheet) return;\n        if (sheet.options.link) {\n            this.insertRules(sheet.rules);\n            return;\n        }\n        this.element.textContent = \"\\n\" + sheet.toString() + \"\\n\";\n    } /**\n   * Insert RuleList into an element.\n   */ ;\n    _proto.insertRules = function insertRules(rules, nativeParent) {\n        for(var i = 0; i < rules.index.length; i++){\n            this.insertRule(rules.index[i], i, nativeParent);\n        }\n    } /**\n   * Insert a rule into element.\n   */ ;\n    _proto.insertRule = function insertRule(rule, index, nativeParent) {\n        if (nativeParent === void 0) {\n            nativeParent = this.element.sheet;\n        }\n        if (rule.rules) {\n            var parent = rule;\n            var latestNativeParent = nativeParent;\n            if (rule.type === \"conditional\" || rule.type === \"keyframes\") {\n                var _insertionIndex = getValidRuleInsertionIndex(nativeParent, index); // We need to render the container without children first.\n                latestNativeParent = _insertRule(nativeParent, parent.toString({\n                    children: false\n                }), _insertionIndex);\n                if (latestNativeParent === false) {\n                    return false;\n                }\n                this.refCssRule(rule, _insertionIndex, latestNativeParent);\n            }\n            this.insertRules(parent.rules, latestNativeParent);\n            return latestNativeParent;\n        }\n        var ruleStr = rule.toString();\n        if (!ruleStr) return false;\n        var insertionIndex = getValidRuleInsertionIndex(nativeParent, index);\n        var nativeRule = _insertRule(nativeParent, ruleStr, insertionIndex);\n        if (nativeRule === false) {\n            return false;\n        }\n        this.hasInsertedRules = true;\n        this.refCssRule(rule, insertionIndex, nativeRule);\n        return nativeRule;\n    };\n    _proto.refCssRule = function refCssRule(rule, index, cssRule) {\n        rule.renderable = cssRule; // We only want to reference the top level rules, deleteRule API doesn't support removing nested rules\n        // like rules inside media queries or keyframes\n        if (rule.options.parent instanceof StyleSheet) {\n            this.cssRules.splice(index, 0, cssRule);\n        }\n    } /**\n   * Delete a rule.\n   */ ;\n    _proto.deleteRule = function deleteRule(cssRule) {\n        var sheet = this.element.sheet;\n        var index = this.indexOf(cssRule);\n        if (index === -1) return false;\n        sheet.deleteRule(index);\n        this.cssRules.splice(index, 1);\n        return true;\n    } /**\n   * Get index of a CSS Rule.\n   */ ;\n    _proto.indexOf = function indexOf(cssRule) {\n        return this.cssRules.indexOf(cssRule);\n    } /**\n   * Generate a new CSS rule and replace the existing one.\n   */ ;\n    _proto.replaceRule = function replaceRule(cssRule, rule) {\n        var index = this.indexOf(cssRule);\n        if (index === -1) return false;\n        this.element.sheet.deleteRule(index);\n        this.cssRules.splice(index, 1);\n        return this.insertRule(rule, index);\n    } /**\n   * Get all rules elements.\n   */ ;\n    _proto.getRules = function getRules() {\n        return this.element.sheet.cssRules;\n    };\n    return DomRenderer;\n}();\nvar instanceCounter = 0;\nvar Jss = /*#__PURE__*/ function() {\n    function Jss(options) {\n        this.id = instanceCounter++;\n        this.version = \"10.10.0\";\n        this.plugins = new PluginsRegistry();\n        this.options = {\n            id: {\n                minify: false\n            },\n            createGenerateId: createGenerateId,\n            Renderer: is_in_browser__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ? DomRenderer : null,\n            plugins: []\n        };\n        this.generateId = createGenerateId({\n            minify: false\n        });\n        for(var i = 0; i < plugins.length; i++){\n            this.plugins.use(plugins[i], {\n                queue: \"internal\"\n            });\n        }\n        this.setup(options);\n    }\n    /**\n   * Prepares various options, applies plugins.\n   * Should not be used twice on the same instance, because there is no plugins\n   * deduplication logic.\n   */ var _proto = Jss.prototype;\n    _proto.setup = function setup(options) {\n        if (options === void 0) {\n            options = {};\n        }\n        if (options.createGenerateId) {\n            this.options.createGenerateId = options.createGenerateId;\n        }\n        if (options.id) {\n            this.options.id = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, this.options.id, options.id);\n        }\n        if (options.createGenerateId || options.id) {\n            this.generateId = this.options.createGenerateId(this.options.id);\n        }\n        if (options.insertionPoint != null) this.options.insertionPoint = options.insertionPoint;\n        if (\"Renderer\" in options) {\n            this.options.Renderer = options.Renderer;\n        } // eslint-disable-next-line prefer-spread\n        if (options.plugins) this.use.apply(this, options.plugins);\n        return this;\n    } /**\n   * Create a Style Sheet.\n   */ ;\n    _proto.createStyleSheet = function createStyleSheet(styles, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var _options = options, index = _options.index;\n        if (typeof index !== \"number\") {\n            index = sheets.index === 0 ? 0 : sheets.index + 1;\n        }\n        var sheet = new StyleSheet(styles, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, options, {\n            jss: this,\n            generateId: options.generateId || this.generateId,\n            insertionPoint: this.options.insertionPoint,\n            Renderer: this.options.Renderer,\n            index: index\n        }));\n        this.plugins.onProcessSheet(sheet);\n        return sheet;\n    } /**\n   * Detach the Style Sheet and remove it from the registry.\n   */ ;\n    _proto.removeStyleSheet = function removeStyleSheet(sheet) {\n        sheet.detach();\n        sheets.remove(sheet);\n        return this;\n    } /**\n   * Create a rule without a Style Sheet.\n   * [Deprecated] will be removed in the next major version.\n   */ ;\n    _proto.createRule = function createRule$1(name, style, options) {\n        if (style === void 0) {\n            style = {};\n        }\n        if (options === void 0) {\n            options = {};\n        }\n        // Enable rule without name for inline styles.\n        if (typeof name === \"object\") {\n            return this.createRule(undefined, name, style);\n        }\n        var ruleOptions = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, options, {\n            name: name,\n            jss: this,\n            Renderer: this.options.Renderer\n        });\n        if (!ruleOptions.generateId) ruleOptions.generateId = this.generateId;\n        if (!ruleOptions.classes) ruleOptions.classes = {};\n        if (!ruleOptions.keyframes) ruleOptions.keyframes = {};\n        var rule = createRule(name, style, ruleOptions);\n        if (rule) this.plugins.onProcessRule(rule);\n        return rule;\n    } /**\n   * Register plugin. Passed function will be invoked with a rule instance.\n   */ ;\n    _proto.use = function use() {\n        var _this = this;\n        for(var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++){\n            plugins[_key] = arguments[_key];\n        }\n        plugins.forEach(function(plugin) {\n            _this.plugins.use(plugin);\n        });\n        return this;\n    };\n    return Jss;\n}();\nvar createJss = function createJss(options) {\n    return new Jss(options);\n};\n/**\n * SheetsManager is like a WeakMap which is designed to count StyleSheet\n * instances and attach/detach automatically.\n * Used in react-jss.\n */ var SheetsManager = /*#__PURE__*/ function() {\n    function SheetsManager() {\n        this.length = 0;\n        this.sheets = new WeakMap();\n    }\n    var _proto = SheetsManager.prototype;\n    _proto.get = function get(key) {\n        var entry = this.sheets.get(key);\n        return entry && entry.sheet;\n    };\n    _proto.add = function add(key, sheet) {\n        if (this.sheets.has(key)) return;\n        this.length++;\n        this.sheets.set(key, {\n            sheet: sheet,\n            refs: 0\n        });\n    };\n    _proto.manage = function manage(key) {\n        var entry = this.sheets.get(key);\n        if (entry) {\n            if (entry.refs === 0) {\n                entry.sheet.attach();\n            }\n            entry.refs++;\n            return entry.sheet;\n        }\n        (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(false, \"[JSS] SheetsManager: can't find sheet to manage\");\n        return undefined;\n    };\n    _proto.unmanage = function unmanage(key) {\n        var entry = this.sheets.get(key);\n        if (entry) {\n            if (entry.refs > 0) {\n                entry.refs--;\n                if (entry.refs === 0) entry.sheet.detach();\n            }\n        } else {\n            (0,tiny_warning__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(false, \"SheetsManager: can't find sheet to unmanage\");\n        }\n    };\n    (0,_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(SheetsManager, [\n        {\n            key: \"size\",\n            get: function get() {\n                return this.length;\n            }\n        }\n    ]);\n    return SheetsManager;\n}();\n/**\n* Export a constant indicating if this browser has CSSTOM support.\n* https://developers.google.com/web/updates/2018/03/cssom\n*/ var hasCSSTOMSupport = typeof CSS === \"object\" && CSS != null && \"number\" in CSS;\n/**\n * Extracts a styles object with only props that contain function values.\n */ function getDynamicStyles(styles) {\n    var to = null;\n    for(var key in styles){\n        var value = styles[key];\n        var type = typeof value;\n        if (type === \"function\") {\n            if (!to) to = {};\n            to[key] = value;\n        } else if (type === \"object\" && value !== null && !Array.isArray(value)) {\n            var extracted = getDynamicStyles(value);\n            if (extracted) {\n                if (!to) to = {};\n                to[key] = extracted;\n            }\n        }\n    }\n    return to;\n}\n/**\n * A better abstraction over CSS.\n *\n * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present\n * @website https://github.com/cssinjs/jss\n * @license MIT\n */ var index = createJss();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (index);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNzL2Rpc3QvanNzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEQ7QUFDbEI7QUFDTDtBQUMrQjtBQUNJO0FBQ2dCO0FBQ2M7QUFFcEcsSUFBSU8sMEJBQTBCLENBQUMsRUFBRUMsV0FBVztBQUM1QyxTQUFTQyxXQUFXQyxLQUFLO0lBQ3ZCLElBQUlBLFNBQVMsUUFBUSxPQUFPQSxVQUFVLFVBQVUsT0FBT0E7SUFDdkQsSUFBSUMsTUFBTUMsT0FBTyxDQUFDRixRQUFRLE9BQU9BLE1BQU1HLEdBQUcsQ0FBQ0o7SUFDM0MsSUFBSUMsTUFBTUYsV0FBVyxLQUFLRCx5QkFBeUIsT0FBT0c7SUFDMUQsSUFBSUksV0FBVyxDQUFDO0lBRWhCLElBQUssSUFBSUMsUUFBUUwsTUFBTztRQUN0QkksUUFBUSxDQUFDQyxLQUFLLEdBQUdOLFdBQVdDLEtBQUssQ0FBQ0ssS0FBSztJQUN6QztJQUVBLE9BQU9EO0FBQ1Q7QUFFQTs7Q0FFQyxHQUVELFNBQVNFLFdBQVdELElBQUksRUFBRUUsSUFBSSxFQUFFQyxPQUFPO0lBQ3JDLElBQUlILFNBQVMsS0FBSyxHQUFHO1FBQ25CQSxPQUFPO0lBQ1Q7SUFFQSxJQUFJSSxNQUFNRCxRQUFRQyxHQUFHO0lBQ3JCLElBQUlDLFdBQVdYLFdBQVdRO0lBQzFCLElBQUlJLE9BQU9GLElBQUlHLE9BQU8sQ0FBQ0MsWUFBWSxDQUFDUixNQUFNSyxVQUFVRjtJQUNwRCxJQUFJRyxNQUFNLE9BQU9BLE1BQU0sMkNBQTJDO0lBRWxFLElBQUlOLElBQUksQ0FBQyxFQUFFLEtBQUssS0FBSztRQXBDdkIsS0FxQ3lDLEdBQUdiLHdEQUFPQSxDQUFDLE9BQU8sd0JBQXdCYSxRQUFRLENBQU07SUFDL0Y7SUFFQSxPQUFPO0FBQ1Q7QUFFQSxJQUFJUyxPQUFPLFNBQVNBLEtBQUtDLEtBQUssRUFBRUMsRUFBRTtJQUNoQyxJQUFJQyxTQUFTO0lBRWIsSUFBSyxJQUFJQyxJQUFJLEdB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LENBQUNrSCxNQUFNO1lBQzFDO1FBQ0YsT0FBTztZQUNML0ssd0RBQU9BLENBQUMsT0FBTztRQUNqQjtJQUNGO0lBRUFDLGtGQUFZQSxDQUFDZ1MsZUFBZTtRQUFDO1lBQzNCdk8sS0FBSztZQUNMdUMsS0FBSyxTQUFTQTtnQkFDWixPQUFPLElBQUksQ0FBQ3RFLE1BQU07WUFDcEI7UUFDRjtLQUFFO0lBRUYsT0FBT3NRO0FBQ1Q7QUFFQTs7O0FBR0EsR0FDQSxJQUFJTyxtQkFBbUIsT0FBT2xQLFFBQVEsWUFBWUEsT0FBTyxRQUFRLFlBQVlBO0FBRTdFOztDQUVDLEdBQ0QsU0FBU21QLGlCQUFpQmpNLE1BQU07SUFDOUIsSUFBSWtNLEtBQUs7SUFFVCxJQUFLLElBQUloUCxPQUFPOEMsT0FBUTtRQUN0QixJQUFJakYsUUFBUWlGLE1BQU0sQ0FBQzlDLElBQUk7UUFDdkIsSUFBSUMsT0FBTyxPQUFPcEM7UUFFbEIsSUFBSW9DLFNBQVMsWUFBWTtZQUN2QixJQUFJLENBQUMrTyxJQUFJQSxLQUFLLENBQUM7WUFDZkEsRUFBRSxDQUFDaFAsSUFBSSxHQUFHbkM7UUFDWixPQUFPLElBQUlvQyxTQUFTLFlBQVlwQyxVQUFVLFFBQVEsQ0FBQ2QsTUFBTUMsT0FBTyxDQUFDYSxRQUFRO1lBQ3ZFLElBQUlvUixZQUFZRixpQkFBaUJsUjtZQUVqQyxJQUFJb1IsV0FBVztnQkFDYixJQUFJLENBQUNELElBQUlBLEtBQUssQ0FBQztnQkFDZkEsRUFBRSxDQUFDaFAsSUFBSSxHQUFHaVA7WUFDWjtRQUNGO0lBQ0Y7SUFFQSxPQUFPRDtBQUNUO0FBRUE7Ozs7OztDQU1DLEdBQ0QsSUFBSXJRLFFBQVEyUDtBQUVaLGlFQUFlM1AsS0FBS0EsRUFBQztBQUN5SSIsInNvdXJjZXMiOlsid2VicGFjazovL3AzM3IvLi9ub2RlX21vZHVsZXMvanNzL2Rpc3QvanNzLmVzbS5qcz83NGE3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCBpc0luQnJvd3NlciBmcm9tICdpcy1pbi1icm93c2VyJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJ3Rpbnktd2FybmluZyc7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzJztcbmltcG9ydCBfaW5oZXJpdHNMb29zZSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c0xvb3NlJztcbmltcG9ydCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2Fzc2VydFRoaXNJbml0aWFsaXplZCc7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSc7XG5cbnZhciBwbGFpbk9iamVjdENvbnN0cnVyY3RvciA9IHt9LmNvbnN0cnVjdG9yO1xuZnVuY3Rpb24gY2xvbmVTdHlsZShzdHlsZSkge1xuICBpZiAoc3R5bGUgPT0gbnVsbCB8fCB0eXBlb2Ygc3R5bGUgIT09ICdvYmplY3QnKSByZXR1cm4gc3R5bGU7XG4gIGlmIChBcnJheS5pc0FycmF5KHN0eWxlKSkgcmV0dXJuIHN0eWxlLm1hcChjbG9uZVN0eWxlKTtcbiAgaWYgKHN0eWxlLmNvbnN0cnVjdG9yICE9PSBwbGFpbk9iamVjdENvbnN0cnVyY3RvcikgcmV0dXJuIHN0eWxlO1xuICB2YXIgbmV3U3R5bGUgPSB7fTtcblxuICBmb3IgKHZhciBuYW1lIGluIHN0eWxlKSB7XG4gICAgbmV3U3R5bGVbbmFtZV0gPSBjbG9uZVN0eWxlKHN0eWxlW25hbWVdKTtcbiAgfVxuXG4gIHJldHVybiBuZXdTdHlsZTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBydWxlIGluc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVJ1bGUobmFtZSwgZGVjbCwgb3B0aW9ucykge1xuICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgbmFtZSA9ICd1bm5hbWVkJztcbiAgfVxuXG4gIHZhciBqc3MgPSBvcHRpb25zLmpzcztcbiAgdmFyIGRlY2xDb3B5ID0gY2xvbmVTdHlsZShkZWNsKTtcbiAgdmFyIHJ1bGUgPSBqc3MucGx1Z2lucy5vbkNyZWF0ZVJ1bGUobmFtZSwgZGVjbENvcHksIG9wdGlvbnMpO1xuICBpZiAocnVsZSkgcmV0dXJuIHJ1bGU7IC8vIEl0IGlzIGFuIGF0LXJ1bGUgYW5kIGl0IGhhcyBubyBpbnN0YW5jZS5cblxuICBpZiAobmFtZVswXSA9PT0gJ0AnKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBVbmtub3duIHJ1bGUgXCIgKyBuYW1lKSA6IHZvaWQgMDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgam9pbiA9IGZ1bmN0aW9uIGpvaW4odmFsdWUsIGJ5KSB7XG4gIHZhciByZXN1bHQgPSAnJztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gUmVtb3ZlICFpbXBvcnRhbnQgZnJvbSB0aGUgdmFsdWUsIGl0IHdpbGwgYmUgcmVhZGRlZCBsYXRlci5cbiAgICBpZiAodmFsdWVbaV0gPT09ICchaW1wb3J0YW50JykgYnJlYWs7XG4gICAgaWYgKHJlc3VsdCkgcmVzdWx0ICs9IGJ5O1xuICAgIHJlc3VsdCArPSB2YWx1ZVtpXTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBKU1MgYXJyYXkgdmFsdWUgdG8gYSBDU1Mgc3RyaW5nLlxuICpcbiAqIGBtYXJnaW46IFtbJzVweCcsICcxMHB4J11dYCA+IGBtYXJnaW46IDVweCAxMHB4O2BcbiAqIGBib3JkZXI6IFsnMXB4JywgJzJweCddYCA+IGBib3JkZXI6IDFweCwgMnB4O2BcbiAqIGBtYXJnaW46IFtbJzVweCcsICcxMHB4J10sICchaW1wb3J0YW50J11gID4gYG1hcmdpbjogNXB4IDEwcHggIWltcG9ydGFudDtgXG4gKiBgY29sb3I6IFsncmVkJywgIWltcG9ydGFudF1gID4gYGNvbG9yOiByZWQgIWltcG9ydGFudDtgXG4gKi9cblxuXG52YXIgdG9Dc3NWYWx1ZSA9IGZ1bmN0aW9uIHRvQ3NzVmFsdWUodmFsdWUpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICB2YXIgY3NzVmFsdWUgPSAnJzsgLy8gU3VwcG9ydCBzcGFjZSBzZXBhcmF0ZWQgdmFsdWVzIHZpYSBgW1snNXB4JywgJzEwcHgnXV1gLlxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlWzBdKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZVtpXSA9PT0gJyFpbXBvcnRhbnQnKSBicmVhaztcbiAgICAgIGlmIChjc3NWYWx1ZSkgY3NzVmFsdWUgKz0gJywgJztcbiAgICAgIGNzc1ZhbHVlICs9IGpvaW4odmFsdWVbaV0sICcgJyk7XG4gICAgfVxuICB9IGVsc2UgY3NzVmFsdWUgPSBqb2luKHZhbHVlLCAnLCAnKTsgLy8gQWRkICFpbXBvcnRhbnQsIGJlY2F1c2UgaXQgd2FzIGlnbm9yZWQuXG5cblxuICBpZiAodmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gPT09ICchaW1wb3J0YW50Jykge1xuICAgIGNzc1ZhbHVlICs9ICcgIWltcG9ydGFudCc7XG4gIH1cblxuICByZXR1cm4gY3NzVmFsdWU7XG59O1xuXG5mdW5jdGlvbiBnZXRXaGl0ZXNwYWNlU3ltYm9scyhvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZm9ybWF0ID09PSBmYWxzZSkge1xuICAgIHJldHVybiB7XG4gICAgICBsaW5lYnJlYWs6ICcnLFxuICAgICAgc3BhY2U6ICcnXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbGluZWJyZWFrOiAnXFxuJyxcbiAgICBzcGFjZTogJyAnXG4gIH07XG59XG5cbi8qKlxuICogSW5kZW50IGEgc3RyaW5nLlxuICogaHR0cDovL2pzcGVyZi5jb20vYXJyYXktam9pbi12cy1mb3JcbiAqL1xuXG5mdW5jdGlvbiBpbmRlbnRTdHIoc3RyLCBpbmRlbnQpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBpbmRlbnQ7IGluZGV4KyspIHtcbiAgICByZXN1bHQgKz0gJyAgJztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQgKyBzdHI7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgUnVsZSB0byBDU1Mgc3RyaW5nLlxuICovXG5cblxuZnVuY3Rpb24gdG9Dc3Moc2VsZWN0b3IsIHN0eWxlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICghc3R5bGUpIHJldHVybiByZXN1bHQ7XG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9ucyRpbmRlbnQgPSBfb3B0aW9ucy5pbmRlbnQsXG4gICAgICBpbmRlbnQgPSBfb3B0aW9ucyRpbmRlbnQgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyRpbmRlbnQ7XG4gIHZhciBmYWxsYmFja3MgPSBzdHlsZS5mYWxsYmFja3M7XG5cbiAgaWYgKG9wdGlvbnMuZm9ybWF0ID09PSBmYWxzZSkge1xuICAgIGluZGVudCA9IC1JbmZpbml0eTtcbiAgfVxuXG4gIHZhciBfZ2V0V2hpdGVzcGFjZVN5bWJvbHMgPSBnZXRXaGl0ZXNwYWNlU3ltYm9scyhvcHRpb25zKSxcbiAgICAgIGxpbmVicmVhayA9IF9nZXRXaGl0ZXNwYWNlU3ltYm9scy5saW5lYnJlYWssXG4gICAgICBzcGFjZSA9IF9nZXRXaGl0ZXNwYWNlU3ltYm9scy5zcGFjZTtcblxuICBpZiAoc2VsZWN0b3IpIGluZGVudCsrOyAvLyBBcHBseSBmYWxsYmFja3MgZmlyc3QuXG5cbiAgaWYgKGZhbGxiYWNrcykge1xuICAgIC8vIEFycmF5IHN5bnRheCB7ZmFsbGJhY2tzOiBbe3Byb3A6IHZhbHVlfV19XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmFsbGJhY2tzKSkge1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGZhbGxiYWNrcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIGZhbGxiYWNrID0gZmFsbGJhY2tzW2luZGV4XTtcblxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGZhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gZmFsbGJhY2tbcHJvcF07XG5cbiAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkgcmVzdWx0ICs9IGxpbmVicmVhaztcbiAgICAgICAgICAgIHJlc3VsdCArPSBpbmRlbnRTdHIocHJvcCArIFwiOlwiICsgc3BhY2UgKyB0b0Nzc1ZhbHVlKHZhbHVlKSArIFwiO1wiLCBpbmRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPYmplY3Qgc3ludGF4IHtmYWxsYmFja3M6IHtwcm9wOiB2YWx1ZX19XG4gICAgICBmb3IgKHZhciBfcHJvcCBpbiBmYWxsYmFja3MpIHtcbiAgICAgICAgdmFyIF92YWx1ZSA9IGZhbGxiYWNrc1tfcHJvcF07XG5cbiAgICAgICAgaWYgKF92YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdCkgcmVzdWx0ICs9IGxpbmVicmVhaztcbiAgICAgICAgICByZXN1bHQgKz0gaW5kZW50U3RyKF9wcm9wICsgXCI6XCIgKyBzcGFjZSArIHRvQ3NzVmFsdWUoX3ZhbHVlKSArIFwiO1wiLCBpbmRlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX3Byb3AyIGluIHN0eWxlKSB7XG4gICAgdmFyIF92YWx1ZTIgPSBzdHlsZVtfcHJvcDJdO1xuXG4gICAgaWYgKF92YWx1ZTIgIT0gbnVsbCAmJiBfcHJvcDIgIT09ICdmYWxsYmFja3MnKSB7XG4gICAgICBpZiAocmVzdWx0KSByZXN1bHQgKz0gbGluZWJyZWFrO1xuICAgICAgcmVzdWx0ICs9IGluZGVudFN0cihfcHJvcDIgKyBcIjpcIiArIHNwYWNlICsgdG9Dc3NWYWx1ZShfdmFsdWUyKSArIFwiO1wiLCBpbmRlbnQpO1xuICAgIH1cbiAgfSAvLyBBbGxvdyBlbXB0eSBzdHlsZSBpbiB0aGlzIGNhc2UsIGJlY2F1c2UgcHJvcGVydGllcyB3aWxsIGJlIGFkZGVkIGR5bmFtaWNhbGx5LlxuXG5cbiAgaWYgKCFyZXN1bHQgJiYgIW9wdGlvbnMuYWxsb3dFbXB0eSkgcmV0dXJuIHJlc3VsdDsgLy8gV2hlbiBydWxlIGlzIGJlaW5nIHN0cmluZ2lmaWVkIGJlZm9yZSBzZWxlY3RvciB3YXMgZGVmaW5lZC5cblxuICBpZiAoIXNlbGVjdG9yKSByZXR1cm4gcmVzdWx0O1xuICBpbmRlbnQtLTtcbiAgaWYgKHJlc3VsdCkgcmVzdWx0ID0gXCJcIiArIGxpbmVicmVhayArIHJlc3VsdCArIGxpbmVicmVhaztcbiAgcmV0dXJuIGluZGVudFN0cihcIlwiICsgc2VsZWN0b3IgKyBzcGFjZSArIFwie1wiICsgcmVzdWx0LCBpbmRlbnQpICsgaW5kZW50U3RyKCd9JywgaW5kZW50KTtcbn1cblxudmFyIGVzY2FwZVJlZ2V4ID0gLyhbW1xcXS4jKiQ+PCt+PXxeOigpLFwiJ2BcXHNdKS9nO1xudmFyIG5hdGl2ZUVzY2FwZSA9IHR5cGVvZiBDU1MgIT09ICd1bmRlZmluZWQnICYmIENTUy5lc2NhcGU7XG52YXIgZXNjYXBlID0gKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIG5hdGl2ZUVzY2FwZSA/IG5hdGl2ZUVzY2FwZShzdHIpIDogc3RyLnJlcGxhY2UoZXNjYXBlUmVnZXgsICdcXFxcJDEnKTtcbn0pO1xuXG52YXIgQmFzZVN0eWxlUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJhc2VTdHlsZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdzdHlsZSc7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHZhciBzaGVldCA9IG9wdGlvbnMuc2hlZXQsXG4gICAgICAgIFJlbmRlcmVyID0gb3B0aW9ucy5SZW5kZXJlcjtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICBpZiAoc2hlZXQpIHRoaXMucmVuZGVyZXIgPSBzaGVldC5yZW5kZXJlcjtlbHNlIGlmIChSZW5kZXJlcikgdGhpcy5yZW5kZXJlciA9IG5ldyBSZW5kZXJlcigpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IGEgc3R5bGUgcHJvcGVydHkuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IEJhc2VTdHlsZVJ1bGUucHJvdG90eXBlO1xuXG4gIF9wcm90by5wcm9wID0gZnVuY3Rpb24gcHJvcChuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIC8vIEl0J3MgYSBnZXR0ZXIuXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLnN0eWxlW25hbWVdOyAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiB0aGUgdmFsdWUgaGFzIG5vdCBjaGFuZ2VkLlxuXG4gICAgdmFyIGZvcmNlID0gb3B0aW9ucyA/IG9wdGlvbnMuZm9yY2UgOiBmYWxzZTtcbiAgICBpZiAoIWZvcmNlICYmIHRoaXMuc3R5bGVbbmFtZV0gPT09IHZhbHVlKSByZXR1cm4gdGhpcztcbiAgICB2YXIgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmICghb3B0aW9ucyB8fCBvcHRpb25zLnByb2Nlc3MgIT09IGZhbHNlKSB7XG4gICAgICBuZXdWYWx1ZSA9IHRoaXMub3B0aW9ucy5qc3MucGx1Z2lucy5vbkNoYW5nZVZhbHVlKHZhbHVlLCBuYW1lLCB0aGlzKTtcbiAgICB9XG5cbiAgICB2YXIgaXNFbXB0eSA9IG5ld1ZhbHVlID09IG51bGwgfHwgbmV3VmFsdWUgPT09IGZhbHNlO1xuICAgIHZhciBpc0RlZmluZWQgPSBuYW1lIGluIHRoaXMuc3R5bGU7IC8vIFZhbHVlIGlzIGVtcHR5IGFuZCB3YXNuJ3QgZGVmaW5lZCBiZWZvcmUuXG5cbiAgICBpZiAoaXNFbXB0eSAmJiAhaXNEZWZpbmVkICYmICFmb3JjZSkgcmV0dXJuIHRoaXM7IC8vIFdlIGFyZSBnb2luZyB0byByZW1vdmUgdGhpcyB2YWx1ZS5cblxuICAgIHZhciByZW1vdmUgPSBpc0VtcHR5ICYmIGlzRGVmaW5lZDtcbiAgICBpZiAocmVtb3ZlKSBkZWxldGUgdGhpcy5zdHlsZVtuYW1lXTtlbHNlIHRoaXMuc3R5bGVbbmFtZV0gPSBuZXdWYWx1ZTsgLy8gUmVuZGVyYWJsZSBpcyBkZWZpbmVkIGlmIFN0eWxlU2hlZXQgb3B0aW9uIGBsaW5rYCBpcyB0cnVlLlxuXG4gICAgaWYgKHRoaXMucmVuZGVyYWJsZSAmJiB0aGlzLnJlbmRlcmVyKSB7XG4gICAgICBpZiAocmVtb3ZlKSB0aGlzLnJlbmRlcmVyLnJlbW92ZVByb3BlcnR5KHRoaXMucmVuZGVyYWJsZSwgbmFtZSk7ZWxzZSB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMucmVuZGVyYWJsZSwgbmFtZSwgbmV3VmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHNoZWV0ID0gdGhpcy5vcHRpb25zLnNoZWV0O1xuXG4gICAgaWYgKHNoZWV0ICYmIHNoZWV0LmF0dGFjaGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCAnW0pTU10gUnVsZSBpcyBub3QgbGlua2VkLiBNaXNzaW5nIHNoZWV0IG9wdGlvbiBcImxpbms6IHRydWVcIi4nKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gQmFzZVN0eWxlUnVsZTtcbn0oKTtcbnZhciBTdHlsZVJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXNlU3R5bGVSdWxlKSB7XG4gIF9pbmhlcml0c0xvb3NlKFN0eWxlUnVsZSwgX0Jhc2VTdHlsZVJ1bGUpO1xuXG4gIGZ1bmN0aW9uIFN0eWxlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQmFzZVN0eWxlUnVsZS5jYWxsKHRoaXMsIGtleSwgc3R5bGUsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgdmFyIHNlbGVjdG9yID0gb3B0aW9ucy5zZWxlY3RvcixcbiAgICAgICAgc2NvcGVkID0gb3B0aW9ucy5zY29wZWQsXG4gICAgICAgIHNoZWV0ID0gb3B0aW9ucy5zaGVldCxcbiAgICAgICAgZ2VuZXJhdGVJZCA9IG9wdGlvbnMuZ2VuZXJhdGVJZDtcblxuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgX3RoaXMuc2VsZWN0b3JUZXh0ID0gc2VsZWN0b3I7XG4gICAgfSBlbHNlIGlmIChzY29wZWQgIT09IGZhbHNlKSB7XG4gICAgICBfdGhpcy5pZCA9IGdlbmVyYXRlSWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksIHNoZWV0KTtcbiAgICAgIF90aGlzLnNlbGVjdG9yVGV4dCA9IFwiLlwiICsgZXNjYXBlKF90aGlzLmlkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBzZWxlY3RvciBzdHJpbmcuXG4gICAqIEF0dGVudGlvbjogdXNlIHRoaXMgd2l0aCBjYXV0aW9uLiBNb3N0IGJyb3dzZXJzIGRpZG4ndCBpbXBsZW1lbnRcbiAgICogc2VsZWN0b3JUZXh0IHNldHRlciwgc28gdGhpcyBtYXkgcmVzdWx0IGluIHJlcmVuZGVyaW5nIG9mIGVudGlyZSBTdHlsZSBTaGVldC5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvMiA9IFN0eWxlUnVsZS5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIEFwcGx5IHJ1bGUgdG8gYW4gZWxlbWVudCBpbmxpbmUuXG4gICAqL1xuICBfcHJvdG8yLmFwcGx5VG8gPSBmdW5jdGlvbiBhcHBseVRvKHJlbmRlcmFibGUpIHtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuXG4gICAgaWYgKHJlbmRlcmVyKSB7XG4gICAgICB2YXIganNvbiA9IHRoaXMudG9KU09OKCk7XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4ganNvbikge1xuICAgICAgICByZW5kZXJlci5zZXRQcm9wZXJ0eShyZW5kZXJhYmxlLCBwcm9wLCBqc29uW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBydWxlLlxuICAgKiBGYWxsYmFja3MgYXJlIG5vdCBzdXBwb3J0ZWQuXG4gICAqIFVzZWZ1bCBmb3IgaW5saW5lIHN0eWxlcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8yLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICB2YXIganNvbiA9IHt9O1xuXG4gICAgZm9yICh2YXIgcHJvcCBpbiB0aGlzLnN0eWxlKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLnN0eWxlW3Byb3BdO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIGpzb25bcHJvcF0gPSB2YWx1ZTtlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkganNvbltwcm9wXSA9IHRvQ3NzVmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBqc29uO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzIudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgdmFyIHNoZWV0ID0gdGhpcy5vcHRpb25zLnNoZWV0O1xuICAgIHZhciBsaW5rID0gc2hlZXQgPyBzaGVldC5vcHRpb25zLmxpbmsgOiBmYWxzZTtcbiAgICB2YXIgb3B0cyA9IGxpbmsgPyBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgYWxsb3dFbXB0eTogdHJ1ZVxuICAgIH0pIDogb3B0aW9ucztcbiAgICByZXR1cm4gdG9Dc3ModGhpcy5zZWxlY3RvclRleHQsIHRoaXMuc3R5bGUsIG9wdHMpO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhTdHlsZVJ1bGUsIFt7XG4gICAga2V5OiBcInNlbGVjdG9yXCIsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoc2VsZWN0b3IpIHtcbiAgICAgIGlmIChzZWxlY3RvciA9PT0gdGhpcy5zZWxlY3RvclRleHQpIHJldHVybjtcbiAgICAgIHRoaXMuc2VsZWN0b3JUZXh0ID0gc2VsZWN0b3I7XG4gICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyLFxuICAgICAgICAgIHJlbmRlcmFibGUgPSB0aGlzLnJlbmRlcmFibGU7XG4gICAgICBpZiAoIXJlbmRlcmFibGUgfHwgIXJlbmRlcmVyKSByZXR1cm47XG4gICAgICB2YXIgaGFzQ2hhbmdlZCA9IHJlbmRlcmVyLnNldFNlbGVjdG9yKHJlbmRlcmFibGUsIHNlbGVjdG9yKTsgLy8gSWYgc2VsZWN0b3Igc2V0dGVyIGlzIG5vdCBpbXBsZW1lbnRlZCwgcmVyZW5kZXIgdGhlIHJ1bGUuXG5cbiAgICAgIGlmICghaGFzQ2hhbmdlZCkge1xuICAgICAgICByZW5kZXJlci5yZXBsYWNlUnVsZShyZW5kZXJhYmxlLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHNlbGVjdG9yIHN0cmluZy5cbiAgICAgKi9cbiAgICAsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RvclRleHQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0eWxlUnVsZTtcbn0oQmFzZVN0eWxlUnVsZSk7XG52YXIgcGx1Z2luU3R5bGVSdWxlID0ge1xuICBvbkNyZWF0ZVJ1bGU6IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgaWYgKGtleVswXSA9PT0gJ0AnIHx8IG9wdGlvbnMucGFyZW50ICYmIG9wdGlvbnMucGFyZW50LnR5cGUgPT09ICdrZXlmcmFtZXMnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFN0eWxlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKTtcbiAgfVxufTtcblxudmFyIGRlZmF1bHRUb1N0cmluZ09wdGlvbnMgPSB7XG4gIGluZGVudDogMSxcbiAgY2hpbGRyZW46IHRydWVcbn07XG52YXIgYXRSZWdFeHAgPSAvQChbXFx3LV0rKS87XG4vKipcbiAqIENvbmRpdGlvbmFsIHJ1bGUgZm9yIEBtZWRpYSwgQHN1cHBvcnRzXG4gKi9cblxudmFyIENvbmRpdGlvbmFsUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbmRpdGlvbmFsUnVsZShrZXksIHN0eWxlcywgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdjb25kaXRpb25hbCc7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHZhciBhdE1hdGNoID0ga2V5Lm1hdGNoKGF0UmVnRXhwKTtcbiAgICB0aGlzLmF0ID0gYXRNYXRjaCA/IGF0TWF0Y2hbMV0gOiAndW5rbm93bic7IC8vIEtleSBtaWdodCBjb250YWluIGEgdW5pcXVlIHN1ZmZpeCBpbiBjYXNlIHRoZSBgbmFtZWAgcGFzc2VkIGJ5IHVzZXIgd2FzIGR1cGxpY2F0ZS5cblxuICAgIHRoaXMucXVlcnkgPSBvcHRpb25zLm5hbWUgfHwgXCJAXCIgKyB0aGlzLmF0O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5ydWxlcyA9IG5ldyBSdWxlTGlzdChfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgcGFyZW50OiB0aGlzXG4gICAgfSkpO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIHRoaXMucnVsZXMuYWRkKG5hbWUsIHN0eWxlc1tuYW1lXSk7XG4gICAgfVxuXG4gICAgdGhpcy5ydWxlcy5wcm9jZXNzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHJ1bGUuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IENvbmRpdGlvbmFsUnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldFJ1bGUgPSBmdW5jdGlvbiBnZXRSdWxlKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy5nZXQobmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBpbmRleCBvZiBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKHJ1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy5pbmRleE9mKHJ1bGUpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIHJlZ2lzdGVyIHJ1bGUsIHJ1biBwbHVnaW5zLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5hZGRSdWxlID0gZnVuY3Rpb24gYWRkUnVsZShuYW1lLCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHZhciBydWxlID0gdGhpcy5ydWxlcy5hZGQobmFtZSwgc3R5bGUsIG9wdGlvbnMpO1xuICAgIGlmICghcnVsZSkgcmV0dXJuIG51bGw7XG4gICAgdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zLm9uUHJvY2Vzc1J1bGUocnVsZSk7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgLyoqXG4gICAqIFJlcGxhY2UgcnVsZSwgcnVuIHBsdWdpbnMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlcGxhY2VSdWxlID0gZnVuY3Rpb24gcmVwbGFjZVJ1bGUobmFtZSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgbmV3UnVsZSA9IHRoaXMucnVsZXMucmVwbGFjZShuYW1lLCBzdHlsZSwgb3B0aW9ucyk7XG4gICAgaWYgKG5ld1J1bGUpIHRoaXMub3B0aW9ucy5qc3MucGx1Z2lucy5vblByb2Nlc3NSdWxlKG5ld1J1bGUpO1xuICAgIHJldHVybiBuZXdSdWxlO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdFRvU3RyaW5nT3B0aW9ucztcbiAgICB9XG5cbiAgICB2YXIgX2dldFdoaXRlc3BhY2VTeW1ib2xzID0gZ2V0V2hpdGVzcGFjZVN5bWJvbHMob3B0aW9ucyksXG4gICAgICAgIGxpbmVicmVhayA9IF9nZXRXaGl0ZXNwYWNlU3ltYm9scy5saW5lYnJlYWs7XG5cbiAgICBpZiAob3B0aW9ucy5pbmRlbnQgPT0gbnVsbCkgb3B0aW9ucy5pbmRlbnQgPSBkZWZhdWx0VG9TdHJpbmdPcHRpb25zLmluZGVudDtcbiAgICBpZiAob3B0aW9ucy5jaGlsZHJlbiA9PSBudWxsKSBvcHRpb25zLmNoaWxkcmVuID0gZGVmYXVsdFRvU3RyaW5nT3B0aW9ucy5jaGlsZHJlbjtcblxuICAgIGlmIChvcHRpb25zLmNoaWxkcmVuID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRoaXMucXVlcnkgKyBcIiB7fVwiO1xuICAgIH1cblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucnVsZXMudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgcmV0dXJuIGNoaWxkcmVuID8gdGhpcy5xdWVyeSArIFwiIHtcIiArIGxpbmVicmVhayArIGNoaWxkcmVuICsgbGluZWJyZWFrICsgXCJ9XCIgOiAnJztcbiAgfTtcblxuICByZXR1cm4gQ29uZGl0aW9uYWxSdWxlO1xufSgpO1xudmFyIGtleVJlZ0V4cCA9IC9AY29udGFpbmVyfEBtZWRpYXxAc3VwcG9ydHNcXHMrLztcbnZhciBwbHVnaW5Db25kaXRpb25hbFJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGtleVJlZ0V4cC50ZXN0KGtleSkgPyBuZXcgQ29uZGl0aW9uYWxSdWxlKGtleSwgc3R5bGVzLCBvcHRpb25zKSA6IG51bGw7XG4gIH1cbn07XG5cbnZhciBkZWZhdWx0VG9TdHJpbmdPcHRpb25zJDEgPSB7XG4gIGluZGVudDogMSxcbiAgY2hpbGRyZW46IHRydWVcbn07XG52YXIgbmFtZVJlZ0V4cCA9IC9Aa2V5ZnJhbWVzXFxzKyhbXFx3LV0rKS87XG4vKipcbiAqIFJ1bGUgZm9yIEBrZXlmcmFtZXNcbiAqL1xuXG52YXIgS2V5ZnJhbWVzUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEtleWZyYW1lc1J1bGUoa2V5LCBmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgPSAna2V5ZnJhbWVzJztcbiAgICB0aGlzLmF0ID0gJ0BrZXlmcmFtZXMnO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB2YXIgbmFtZU1hdGNoID0ga2V5Lm1hdGNoKG5hbWVSZWdFeHApO1xuXG4gICAgaWYgKG5hbWVNYXRjaCAmJiBuYW1lTWF0Y2hbMV0pIHtcbiAgICAgIHRoaXMubmFtZSA9IG5hbWVNYXRjaFsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5uYW1lID0gJ25vbmFtZSc7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIEJhZCBrZXlmcmFtZXMgbmFtZSBcIiArIGtleSkgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdGhpcy5rZXkgPSB0aGlzLnR5cGUgKyBcIi1cIiArIHRoaXMubmFtZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHZhciBzY29wZWQgPSBvcHRpb25zLnNjb3BlZCxcbiAgICAgICAgc2hlZXQgPSBvcHRpb25zLnNoZWV0LFxuICAgICAgICBnZW5lcmF0ZUlkID0gb3B0aW9ucy5nZW5lcmF0ZUlkO1xuICAgIHRoaXMuaWQgPSBzY29wZWQgPT09IGZhbHNlID8gdGhpcy5uYW1lIDogZXNjYXBlKGdlbmVyYXRlSWQodGhpcywgc2hlZXQpKTtcbiAgICB0aGlzLnJ1bGVzID0gbmV3IFJ1bGVMaXN0KF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBwYXJlbnQ6IHRoaXNcbiAgICB9KSk7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIGZyYW1lcykge1xuICAgICAgdGhpcy5ydWxlcy5hZGQobmFtZSwgZnJhbWVzW25hbWVdLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgICBwYXJlbnQ6IHRoaXNcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzLnByb2Nlc3MoKTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gS2V5ZnJhbWVzUnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0VG9TdHJpbmdPcHRpb25zJDE7XG4gICAgfVxuXG4gICAgdmFyIF9nZXRXaGl0ZXNwYWNlU3ltYm9scyA9IGdldFdoaXRlc3BhY2VTeW1ib2xzKG9wdGlvbnMpLFxuICAgICAgICBsaW5lYnJlYWsgPSBfZ2V0V2hpdGVzcGFjZVN5bWJvbHMubGluZWJyZWFrO1xuXG4gICAgaWYgKG9wdGlvbnMuaW5kZW50ID09IG51bGwpIG9wdGlvbnMuaW5kZW50ID0gZGVmYXVsdFRvU3RyaW5nT3B0aW9ucyQxLmluZGVudDtcbiAgICBpZiAob3B0aW9ucy5jaGlsZHJlbiA9PSBudWxsKSBvcHRpb25zLmNoaWxkcmVuID0gZGVmYXVsdFRvU3RyaW5nT3B0aW9ucyQxLmNoaWxkcmVuO1xuXG4gICAgaWYgKG9wdGlvbnMuY2hpbGRyZW4gPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdCArIFwiIFwiICsgdGhpcy5pZCArIFwiIHt9XCI7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5ydWxlcy50b1N0cmluZyhvcHRpb25zKTtcbiAgICBpZiAoY2hpbGRyZW4pIGNoaWxkcmVuID0gXCJcIiArIGxpbmVicmVhayArIGNoaWxkcmVuICsgbGluZWJyZWFrO1xuICAgIHJldHVybiB0aGlzLmF0ICsgXCIgXCIgKyB0aGlzLmlkICsgXCIge1wiICsgY2hpbGRyZW4gKyBcIn1cIjtcbiAgfTtcblxuICByZXR1cm4gS2V5ZnJhbWVzUnVsZTtcbn0oKTtcbnZhciBrZXlSZWdFeHAkMSA9IC9Aa2V5ZnJhbWVzXFxzKy87XG52YXIgcmVmUmVnRXhwID0gL1xcJChbXFx3LV0rKS9nO1xuXG52YXIgZmluZFJlZmVyZW5jZWRLZXlmcmFtZSA9IGZ1bmN0aW9uIGZpbmRSZWZlcmVuY2VkS2V5ZnJhbWUodmFsLCBrZXlmcmFtZXMpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbC5yZXBsYWNlKHJlZlJlZ0V4cCwgZnVuY3Rpb24gKG1hdGNoLCBuYW1lKSB7XG4gICAgICBpZiAobmFtZSBpbiBrZXlmcmFtZXMpIHtcbiAgICAgICAgcmV0dXJuIGtleWZyYW1lc1tuYW1lXTtcbiAgICAgIH1cblxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBSZWZlcmVuY2VkIGtleWZyYW1lcyBydWxlIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQuXCIpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn07XG4vKipcbiAqIFJlcGxhY2UgdGhlIHJlZmVyZW5jZSBmb3IgYSBhbmltYXRpb24gbmFtZS5cbiAqL1xuXG5cbnZhciByZXBsYWNlUmVmID0gZnVuY3Rpb24gcmVwbGFjZVJlZihzdHlsZSwgcHJvcCwga2V5ZnJhbWVzKSB7XG4gIHZhciB2YWx1ZSA9IHN0eWxlW3Byb3BdO1xuICB2YXIgcmVmS2V5ZnJhbWUgPSBmaW5kUmVmZXJlbmNlZEtleWZyYW1lKHZhbHVlLCBrZXlmcmFtZXMpO1xuXG4gIGlmIChyZWZLZXlmcmFtZSAhPT0gdmFsdWUpIHtcbiAgICBzdHlsZVtwcm9wXSA9IHJlZktleWZyYW1lO1xuICB9XG59O1xuXG52YXIgcGx1Z2luS2V5ZnJhbWVzUnVsZSA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUoa2V5LCBmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5UmVnRXhwJDEudGVzdChrZXkpID8gbmV3IEtleWZyYW1lc1J1bGUoa2V5LCBmcmFtZXMsIG9wdGlvbnMpIDogbnVsbDtcbiAgfSxcbiAgLy8gQW5pbWF0aW9uIG5hbWUgcmVmIHJlcGxhY2VyLlxuICBvblByb2Nlc3NTdHlsZTogZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUsIHNoZWV0KSB7XG4gICAgaWYgKHJ1bGUudHlwZSAhPT0gJ3N0eWxlJyB8fCAhc2hlZXQpIHJldHVybiBzdHlsZTtcbiAgICBpZiAoJ2FuaW1hdGlvbi1uYW1lJyBpbiBzdHlsZSkgcmVwbGFjZVJlZihzdHlsZSwgJ2FuaW1hdGlvbi1uYW1lJywgc2hlZXQua2V5ZnJhbWVzKTtcbiAgICBpZiAoJ2FuaW1hdGlvbicgaW4gc3R5bGUpIHJlcGxhY2VSZWYoc3R5bGUsICdhbmltYXRpb24nLCBzaGVldC5rZXlmcmFtZXMpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcbiAgb25DaGFuZ2VWYWx1ZTogZnVuY3Rpb24gb25DaGFuZ2VWYWx1ZSh2YWwsIHByb3AsIHJ1bGUpIHtcbiAgICB2YXIgc2hlZXQgPSBydWxlLm9wdGlvbnMuc2hlZXQ7XG5cbiAgICBpZiAoIXNoZWV0KSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIHN3aXRjaCAocHJvcCkge1xuICAgICAgY2FzZSAnYW5pbWF0aW9uJzpcbiAgICAgICAgcmV0dXJuIGZpbmRSZWZlcmVuY2VkS2V5ZnJhbWUodmFsLCBzaGVldC5rZXlmcmFtZXMpO1xuXG4gICAgICBjYXNlICdhbmltYXRpb24tbmFtZSc6XG4gICAgICAgIHJldHVybiBmaW5kUmVmZXJlbmNlZEtleWZyYW1lKHZhbCwgc2hlZXQua2V5ZnJhbWVzKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBLZXlmcmFtZVJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXNlU3R5bGVSdWxlKSB7XG4gIF9pbmhlcml0c0xvb3NlKEtleWZyYW1lUnVsZSwgX0Jhc2VTdHlsZVJ1bGUpO1xuXG4gIGZ1bmN0aW9uIEtleWZyYW1lUnVsZSgpIHtcbiAgICByZXR1cm4gX0Jhc2VTdHlsZVJ1bGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEtleWZyYW1lUnVsZS5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgdmFyIHNoZWV0ID0gdGhpcy5vcHRpb25zLnNoZWV0O1xuICAgIHZhciBsaW5rID0gc2hlZXQgPyBzaGVldC5vcHRpb25zLmxpbmsgOiBmYWxzZTtcbiAgICB2YXIgb3B0cyA9IGxpbmsgPyBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgYWxsb3dFbXB0eTogdHJ1ZVxuICAgIH0pIDogb3B0aW9ucztcbiAgICByZXR1cm4gdG9Dc3ModGhpcy5rZXksIHRoaXMuc3R5bGUsIG9wdHMpO1xuICB9O1xuXG4gIHJldHVybiBLZXlmcmFtZVJ1bGU7XG59KEJhc2VTdHlsZVJ1bGUpO1xudmFyIHBsdWdpbktleWZyYW1lUnVsZSA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnBhcmVudCAmJiBvcHRpb25zLnBhcmVudC50eXBlID09PSAna2V5ZnJhbWVzJykge1xuICAgICAgcmV0dXJuIG5ldyBLZXlmcmFtZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbnZhciBGb250RmFjZVJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGb250RmFjZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdmb250LWZhY2UnO1xuICAgIHRoaXMuYXQgPSAnQGZvbnQtZmFjZSc7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBGb250RmFjZVJ1bGUucHJvdG90eXBlO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICB2YXIgX2dldFdoaXRlc3BhY2VTeW1ib2xzID0gZ2V0V2hpdGVzcGFjZVN5bWJvbHMob3B0aW9ucyksXG4gICAgICAgIGxpbmVicmVhayA9IF9nZXRXaGl0ZXNwYWNlU3ltYm9scy5saW5lYnJlYWs7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnN0eWxlKSkge1xuICAgICAgdmFyIHN0ciA9ICcnO1xuXG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5zdHlsZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgc3RyICs9IHRvQ3NzKHRoaXMuYXQsIHRoaXMuc3R5bGVbaW5kZXhdKTtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGVbaW5kZXggKyAxXSkgc3RyICs9IGxpbmVicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9Dc3ModGhpcy5hdCwgdGhpcy5zdHlsZSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIEZvbnRGYWNlUnVsZTtcbn0oKTtcbnZhciBrZXlSZWdFeHAkMiA9IC9AZm9udC1mYWNlLztcbnZhciBwbHVnaW5Gb250RmFjZVJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4ga2V5UmVnRXhwJDIudGVzdChrZXkpID8gbmV3IEZvbnRGYWNlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSA6IG51bGw7XG4gIH1cbn07XG5cbnZhciBWaWV3cG9ydFJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBWaWV3cG9ydFJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICd2aWV3cG9ydCc7XG4gICAgdGhpcy5hdCA9ICdAdmlld3BvcnQnO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gVmlld3BvcnRSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRvQ3NzKHRoaXMua2V5LCB0aGlzLnN0eWxlLCBvcHRpb25zKTtcbiAgfTtcblxuICByZXR1cm4gVmlld3BvcnRSdWxlO1xufSgpO1xudmFyIHBsdWdpblZpZXdwb3J0UnVsZSA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBrZXkgPT09ICdAdmlld3BvcnQnIHx8IGtleSA9PT0gJ0AtbXMtdmlld3BvcnQnID8gbmV3IFZpZXdwb3J0UnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSA6IG51bGw7XG4gIH1cbn07XG5cbnZhciBTaW1wbGVSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2ltcGxlUnVsZShrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlID0gJ3NpbXBsZSc7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cblxuICB2YXIgX3Byb3RvID0gU2ltcGxlUnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMudmFsdWUpKSB7XG4gICAgICB2YXIgc3RyID0gJyc7XG5cbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnZhbHVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBzdHIgKz0gdGhpcy5rZXkgKyBcIiBcIiArIHRoaXMudmFsdWVbaW5kZXhdICsgXCI7XCI7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlW2luZGV4ICsgMV0pIHN0ciArPSAnXFxuJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5rZXkgKyBcIiBcIiArIHRoaXMudmFsdWUgKyBcIjtcIjtcbiAgfTtcblxuICByZXR1cm4gU2ltcGxlUnVsZTtcbn0oKTtcbnZhciBrZXlzTWFwID0ge1xuICAnQGNoYXJzZXQnOiB0cnVlLFxuICAnQGltcG9ydCc6IHRydWUsXG4gICdAbmFtZXNwYWNlJzogdHJ1ZVxufTtcbnZhciBwbHVnaW5TaW1wbGVSdWxlID0ge1xuICBvbkNyZWF0ZVJ1bGU6IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGtleSBpbiBrZXlzTWFwID8gbmV3IFNpbXBsZVJ1bGUoa2V5LCB2YWx1ZSwgb3B0aW9ucykgOiBudWxsO1xuICB9XG59O1xuXG52YXIgcGx1Z2lucyA9IFtwbHVnaW5TdHlsZVJ1bGUsIHBsdWdpbkNvbmRpdGlvbmFsUnVsZSwgcGx1Z2luS2V5ZnJhbWVzUnVsZSwgcGx1Z2luS2V5ZnJhbWVSdWxlLCBwbHVnaW5Gb250RmFjZVJ1bGUsIHBsdWdpblZpZXdwb3J0UnVsZSwgcGx1Z2luU2ltcGxlUnVsZV07XG5cbnZhciBkZWZhdWx0VXBkYXRlT3B0aW9ucyA9IHtcbiAgcHJvY2VzczogdHJ1ZVxufTtcbnZhciBmb3JjZVVwZGF0ZU9wdGlvbnMgPSB7XG4gIGZvcmNlOiB0cnVlLFxuICBwcm9jZXNzOiB0cnVlXG4gIC8qKlxuICAgKiBDb250YWlucyBydWxlcyBvYmplY3RzIGFuZCBhbGxvd3MgYWRkaW5nL3JlbW92aW5nIGV0Yy5cbiAgICogSXMgdXNlZCBmb3IgZS5nLiBieSBgU3R5bGVTaGVldGAgb3IgYENvbmRpdGlvbmFsUnVsZWAuXG4gICAqL1xuXG59O1xuXG52YXIgUnVsZUxpc3QgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvLyBSdWxlcyByZWdpc3RyeSBmb3IgYWNjZXNzIGJ5IC5nZXQoKSBtZXRob2QuXG4gIC8vIEl0IGNvbnRhaW5zIHRoZSBzYW1lIHJ1bGUgcmVnaXN0ZXJlZCBieSBuYW1lIGFuZCBieSBzZWxlY3Rvci5cbiAgLy8gT3JpZ2luYWwgc3R5bGVzIG9iamVjdC5cbiAgLy8gVXNlZCB0byBlbnN1cmUgY29ycmVjdCBydWxlcyBvcmRlci5cbiAgZnVuY3Rpb24gUnVsZUxpc3Qob3B0aW9ucykge1xuICAgIHRoaXMubWFwID0ge307XG4gICAgdGhpcy5yYXcgPSB7fTtcbiAgICB0aGlzLmluZGV4ID0gW107XG4gICAgdGhpcy5jb3VudGVyID0gMDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuY2xhc3NlcyA9IG9wdGlvbnMuY2xhc3NlcztcbiAgICB0aGlzLmtleWZyYW1lcyA9IG9wdGlvbnMua2V5ZnJhbWVzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIHJlZ2lzdGVyIHJ1bGUuXG4gICAqXG4gICAqIFdpbGwgbm90IHJlbmRlciBhZnRlciBTdHlsZSBTaGVldCB3YXMgcmVuZGVyZWQgdGhlIGZpcnN0IHRpbWUuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFJ1bGVMaXN0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKG5hbWUsIGRlY2wsIHJ1bGVPcHRpb25zKSB7XG4gICAgdmFyIF90aGlzJG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHBhcmVudCA9IF90aGlzJG9wdGlvbnMucGFyZW50LFxuICAgICAgICBzaGVldCA9IF90aGlzJG9wdGlvbnMuc2hlZXQsXG4gICAgICAgIGpzcyA9IF90aGlzJG9wdGlvbnMuanNzLFxuICAgICAgICBSZW5kZXJlciA9IF90aGlzJG9wdGlvbnMuUmVuZGVyZXIsXG4gICAgICAgIGdlbmVyYXRlSWQgPSBfdGhpcyRvcHRpb25zLmdlbmVyYXRlSWQsXG4gICAgICAgIHNjb3BlZCA9IF90aGlzJG9wdGlvbnMuc2NvcGVkO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBfZXh0ZW5kcyh7XG4gICAgICBjbGFzc2VzOiB0aGlzLmNsYXNzZXMsXG4gICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgIHNoZWV0OiBzaGVldCxcbiAgICAgIGpzczoganNzLFxuICAgICAgUmVuZGVyZXI6IFJlbmRlcmVyLFxuICAgICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZCxcbiAgICAgIHNjb3BlZDogc2NvcGVkLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGtleWZyYW1lczogdGhpcy5rZXlmcmFtZXMsXG4gICAgICBzZWxlY3RvcjogdW5kZWZpbmVkXG4gICAgfSwgcnVsZU9wdGlvbnMpOyAvLyBXaGVuIHVzZXIgdXNlcyAuY3JlYXRlU3R5bGVTaGVldCgpLCBkdXBsaWNhdGUgbmFtZXMgYXJlIG5vdCBwb3NzaWJsZSwgYnV0XG4gICAgLy8gYHNoZWV0LmFkZFJ1bGUoKWAgb3BlbnMgdGhlIGRvb3IgZm9yIGFueSBkdXBsaWNhdGUgcnVsZSBuYW1lLiBXaGVuIHRoaXMgaGFwcGVuc1xuICAgIC8vIHdlIG5lZWQgdG8gbWFrZSB0aGUga2V5IHVuaXF1ZSB3aXRoaW4gdGhpcyBSdWxlTGlzdCBpbnN0YW5jZSBzY29wZS5cblxuXG4gICAgdmFyIGtleSA9IG5hbWU7XG5cbiAgICBpZiAobmFtZSBpbiB0aGlzLnJhdykge1xuICAgICAga2V5ID0gbmFtZSArIFwiLWRcIiArIHRoaXMuY291bnRlcisrO1xuICAgIH0gLy8gV2UgbmVlZCB0byBzYXZlIHRoZSBvcmlnaW5hbCBkZWNsIGJlZm9yZSBjcmVhdGluZyB0aGUgcnVsZVxuICAgIC8vIGJlY2F1c2UgY2FjaGUgcGx1Z2luIG5lZWRzIHRvIHVzZSBpdCBhcyBhIGtleSB0byByZXR1cm4gYSBjYWNoZWQgcnVsZS5cblxuXG4gICAgdGhpcy5yYXdba2V5XSA9IGRlY2w7XG5cbiAgICBpZiAoa2V5IGluIHRoaXMuY2xhc3Nlcykge1xuICAgICAgLy8gRS5nLiBydWxlcyBpbnNpZGUgb2YgQG1lZGlhIGNvbnRhaW5lclxuICAgICAgb3B0aW9ucy5zZWxlY3RvciA9IFwiLlwiICsgZXNjYXBlKHRoaXMuY2xhc3Nlc1trZXldKTtcbiAgICB9XG5cbiAgICB2YXIgcnVsZSA9IGNyZWF0ZVJ1bGUoa2V5LCBkZWNsLCBvcHRpb25zKTtcbiAgICBpZiAoIXJ1bGUpIHJldHVybiBudWxsO1xuICAgIHRoaXMucmVnaXN0ZXIocnVsZSk7XG4gICAgdmFyIGluZGV4ID0gb3B0aW9ucy5pbmRleCA9PT0gdW5kZWZpbmVkID8gdGhpcy5pbmRleC5sZW5ndGggOiBvcHRpb25zLmluZGV4O1xuICAgIHRoaXMuaW5kZXguc3BsaWNlKGluZGV4LCAwLCBydWxlKTtcbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuICAvKipcbiAgICogUmVwbGFjZSBydWxlLlxuICAgKiBDcmVhdGUgYSBuZXcgcnVsZSBhbmQgcmVtb3ZlIG9sZCBvbmUgaW5zdGVhZCBvZiBvdmVyd3JpdGluZ1xuICAgKiBiZWNhdXNlIHdlIHdhbnQgdG8gaW52b2tlIG9uQ3JlYXRlUnVsZSBob29rIHRvIG1ha2UgcGx1Z2lucyB3b3JrLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShuYW1lLCBkZWNsLCBydWxlT3B0aW9ucykge1xuICAgIHZhciBvbGRSdWxlID0gdGhpcy5nZXQobmFtZSk7XG4gICAgdmFyIG9sZEluZGV4ID0gdGhpcy5pbmRleC5pbmRleE9mKG9sZFJ1bGUpO1xuXG4gICAgaWYgKG9sZFJ1bGUpIHtcbiAgICAgIHRoaXMucmVtb3ZlKG9sZFJ1bGUpO1xuICAgIH1cblxuICAgIHZhciBvcHRpb25zID0gcnVsZU9wdGlvbnM7XG4gICAgaWYgKG9sZEluZGV4ICE9PSAtMSkgb3B0aW9ucyA9IF9leHRlbmRzKHt9LCBydWxlT3B0aW9ucywge1xuICAgICAgaW5kZXg6IG9sZEluZGV4XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuYWRkKG5hbWUsIGRlY2wsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBydWxlIGJ5IG5hbWUgb3Igc2VsZWN0b3IuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChuYW1lT3JTZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLm1hcFtuYW1lT3JTZWxlY3Rvcl07XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShydWxlKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyKHJ1bGUpO1xuICAgIGRlbGV0ZSB0aGlzLnJhd1tydWxlLmtleV07XG4gICAgdGhpcy5pbmRleC5zcGxpY2UodGhpcy5pbmRleC5pbmRleE9mKHJ1bGUpLCAxKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGluZGV4IG9mIGEgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YocnVsZSkge1xuICAgIHJldHVybiB0aGlzLmluZGV4LmluZGV4T2YocnVsZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJ1biBgb25Qcm9jZXNzUnVsZSgpYCBwbHVnaW5zIG9uIGV2ZXJ5IHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnByb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzKCkge1xuICAgIHZhciBwbHVnaW5zID0gdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zOyAvLyBXZSBuZWVkIHRvIGNsb25lIGFycmF5IGJlY2F1c2UgaWYgd2UgbW9kaWZ5IHRoZSBpbmRleCBzb21ld2hlcmUgZWxzZSBkdXJpbmcgYSBsb29wXG4gICAgLy8gd2UgZW5kIHVwIHdpdGggdmVyeSBoYXJkLXRvLXRyYWNrLWRvd24gc2lkZSBlZmZlY3RzLlxuXG4gICAgdGhpcy5pbmRleC5zbGljZSgwKS5mb3JFYWNoKHBsdWdpbnMub25Qcm9jZXNzUnVsZSwgcGx1Z2lucyk7XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgcnVsZSBpbiBgLm1hcGAsIGAuY2xhc3Nlc2AgYW5kIGAua2V5ZnJhbWVzYCBtYXBzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKHJ1bGUpIHtcbiAgICB0aGlzLm1hcFtydWxlLmtleV0gPSBydWxlO1xuXG4gICAgaWYgKHJ1bGUgaW5zdGFuY2VvZiBTdHlsZVJ1bGUpIHtcbiAgICAgIHRoaXMubWFwW3J1bGUuc2VsZWN0b3JdID0gcnVsZTtcbiAgICAgIGlmIChydWxlLmlkKSB0aGlzLmNsYXNzZXNbcnVsZS5rZXldID0gcnVsZS5pZDtcbiAgICB9IGVsc2UgaWYgKHJ1bGUgaW5zdGFuY2VvZiBLZXlmcmFtZXNSdWxlICYmIHRoaXMua2V5ZnJhbWVzKSB7XG4gICAgICB0aGlzLmtleWZyYW1lc1tydWxlLm5hbWVdID0gcnVsZS5pZDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVucmVnaXN0ZXIgYSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51bnJlZ2lzdGVyID0gZnVuY3Rpb24gdW5yZWdpc3RlcihydWxlKSB7XG4gICAgZGVsZXRlIHRoaXMubWFwW3J1bGUua2V5XTtcblxuICAgIGlmIChydWxlIGluc3RhbmNlb2YgU3R5bGVSdWxlKSB7XG4gICAgICBkZWxldGUgdGhpcy5tYXBbcnVsZS5zZWxlY3Rvcl07XG4gICAgICBkZWxldGUgdGhpcy5jbGFzc2VzW3J1bGUua2V5XTtcbiAgICB9IGVsc2UgaWYgKHJ1bGUgaW5zdGFuY2VvZiBLZXlmcmFtZXNSdWxlKSB7XG4gICAgICBkZWxldGUgdGhpcy5rZXlmcmFtZXNbcnVsZS5uYW1lXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgZnVuY3Rpb24gdmFsdWVzIHdpdGggYSBuZXcgZGF0YS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHZhciBuYW1lO1xuICAgIHZhciBkYXRhO1xuICAgIHZhciBvcHRpb25zO1xuXG4gICAgaWYgKHR5cGVvZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgICBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdO1xuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1syXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgICAgIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV07XG4gICAgICBuYW1lID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgdGhpcy51cGRhdGVPbmUodGhpcy5nZXQobmFtZSksIGRhdGEsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5pbmRleC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdGhpcy51cGRhdGVPbmUodGhpcy5pbmRleFtpbmRleF0sIGRhdGEsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZSBwbHVnaW5zLCB1cGRhdGUgcnVsZSBwcm9wcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udXBkYXRlT25lID0gZnVuY3Rpb24gdXBkYXRlT25lKHJ1bGUsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdFVwZGF0ZU9wdGlvbnM7XG4gICAgfVxuXG4gICAgdmFyIF90aGlzJG9wdGlvbnMyID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBwbHVnaW5zID0gX3RoaXMkb3B0aW9uczIuanNzLnBsdWdpbnMsXG4gICAgICAgIHNoZWV0ID0gX3RoaXMkb3B0aW9uczIuc2hlZXQ7IC8vIEl0IGlzIGEgcnVsZXMgY29udGFpbmVyIGxpa2UgZm9yIGUuZy4gQ29uZGl0aW9uYWxSdWxlLlxuXG4gICAgaWYgKHJ1bGUucnVsZXMgaW5zdGFuY2VvZiBSdWxlTGlzdCkge1xuICAgICAgcnVsZS5ydWxlcy51cGRhdGUoZGF0YSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gcnVsZS5zdHlsZTtcbiAgICBwbHVnaW5zLm9uVXBkYXRlKGRhdGEsIHJ1bGUsIHNoZWV0LCBvcHRpb25zKTsgLy8gV2UgcmVseSBvbiBhIG5ldyBgc3R5bGVgIHJlZiBpbiBjYXNlIGl0IHdhcyBtdXRhdGVkIGR1cmluZyBvblVwZGF0ZSBob29rLlxuXG4gICAgaWYgKG9wdGlvbnMucHJvY2VzcyAmJiBzdHlsZSAmJiBzdHlsZSAhPT0gcnVsZS5zdHlsZSkge1xuICAgICAgLy8gV2UgbmVlZCB0byBydW4gdGhlIHBsdWdpbnMgaW4gY2FzZSBuZXcgYHN0eWxlYCByZWxpZXMgb24gc3ludGF4IHBsdWdpbnMuXG4gICAgICBwbHVnaW5zLm9uUHJvY2Vzc1N0eWxlKHJ1bGUuc3R5bGUsIHJ1bGUsIHNoZWV0KTsgLy8gVXBkYXRlIGFuZCBhZGQgcHJvcHMuXG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gcnVsZS5zdHlsZSkge1xuICAgICAgICB2YXIgbmV4dFZhbHVlID0gcnVsZS5zdHlsZVtwcm9wXTtcbiAgICAgICAgdmFyIHByZXZWYWx1ZSA9IHN0eWxlW3Byb3BdOyAvLyBXZSBuZWVkIHRvIHVzZSBgZm9yY2U6IHRydWVgIGJlY2F1c2UgYHJ1bGUuc3R5bGVgIGhhcyBiZWVuIHVwZGF0ZWQgZHVyaW5nIG9uVXBkYXRlIGhvb2ssIHNvIGBydWxlLnByb3AoKWAgd2lsbCBub3QgdXBkYXRlIHRoZSBDU1NPTSBydWxlLlxuICAgICAgICAvLyBXZSBkbyB0aGlzIGNvbXBhcmlzb24gdG8gYXZvaWQgdW5uZWVkZWQgYHJ1bGUucHJvcCgpYCBjYWxscywgc2luY2Ugd2UgaGF2ZSB0aGUgb2xkIGBzdHlsZWAgb2JqZWN0IGhlcmUuXG5cbiAgICAgICAgaWYgKG5leHRWYWx1ZSAhPT0gcHJldlZhbHVlKSB7XG4gICAgICAgICAgcnVsZS5wcm9wKHByb3AsIG5leHRWYWx1ZSwgZm9yY2VVcGRhdGVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBSZW1vdmUgcHJvcHMuXG5cblxuICAgICAgZm9yICh2YXIgX3Byb3AgaW4gc3R5bGUpIHtcbiAgICAgICAgdmFyIF9uZXh0VmFsdWUgPSBydWxlLnN0eWxlW19wcm9wXTtcbiAgICAgICAgdmFyIF9wcmV2VmFsdWUgPSBzdHlsZVtfcHJvcF07IC8vIFdlIG5lZWQgdG8gdXNlIGBmb3JjZTogdHJ1ZWAgYmVjYXVzZSBgcnVsZS5zdHlsZWAgaGFzIGJlZW4gdXBkYXRlZCBkdXJpbmcgb25VcGRhdGUgaG9vaywgc28gYHJ1bGUucHJvcCgpYCB3aWxsIG5vdCB1cGRhdGUgdGhlIENTU09NIHJ1bGUuXG4gICAgICAgIC8vIFdlIGRvIHRoaXMgY29tcGFyaXNvbiB0byBhdm9pZCB1bm5lZWRlZCBgcnVsZS5wcm9wKClgIGNhbGxzLCBzaW5jZSB3ZSBoYXZlIHRoZSBvbGQgYHN0eWxlYCBvYmplY3QgaGVyZS5cblxuICAgICAgICBpZiAoX25leHRWYWx1ZSA9PSBudWxsICYmIF9uZXh0VmFsdWUgIT09IF9wcmV2VmFsdWUpIHtcbiAgICAgICAgICBydWxlLnByb3AoX3Byb3AsIG51bGwsIGZvcmNlVXBkYXRlT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgcnVsZXMgdG8gYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgdmFyIHNoZWV0ID0gdGhpcy5vcHRpb25zLnNoZWV0O1xuICAgIHZhciBsaW5rID0gc2hlZXQgPyBzaGVldC5vcHRpb25zLmxpbmsgOiBmYWxzZTtcblxuICAgIHZhciBfZ2V0V2hpdGVzcGFjZVN5bWJvbHMgPSBnZXRXaGl0ZXNwYWNlU3ltYm9scyhvcHRpb25zKSxcbiAgICAgICAgbGluZWJyZWFrID0gX2dldFdoaXRlc3BhY2VTeW1ib2xzLmxpbmVicmVhaztcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmluZGV4Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIHJ1bGUgPSB0aGlzLmluZGV4W2luZGV4XTtcbiAgICAgIHZhciBjc3MgPSBydWxlLnRvU3RyaW5nKG9wdGlvbnMpOyAvLyBObyBuZWVkIHRvIHJlbmRlciBhbiBlbXB0eSBydWxlLlxuXG4gICAgICBpZiAoIWNzcyAmJiAhbGluaykgY29udGludWU7XG4gICAgICBpZiAoc3RyKSBzdHIgKz0gbGluZWJyZWFrO1xuICAgICAgc3RyICs9IGNzcztcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIHJldHVybiBSdWxlTGlzdDtcbn0oKTtcblxudmFyIFN0eWxlU2hlZXQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdHlsZVNoZWV0KHN0eWxlcywgb3B0aW9ucykge1xuICAgIHRoaXMuYXR0YWNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlcGxveWVkID0gZmFsc2U7XG4gICAgdGhpcy5jbGFzc2VzID0ge307XG4gICAgdGhpcy5rZXlmcmFtZXMgPSB7fTtcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgc2hlZXQ6IHRoaXMsXG4gICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICBjbGFzc2VzOiB0aGlzLmNsYXNzZXMsXG4gICAgICBrZXlmcmFtZXM6IHRoaXMua2V5ZnJhbWVzXG4gICAgfSk7XG5cbiAgICBpZiAob3B0aW9ucy5SZW5kZXJlcikge1xuICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyBvcHRpb25zLlJlbmRlcmVyKHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMgPSBuZXcgUnVsZUxpc3QodGhpcy5vcHRpb25zKTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICB0aGlzLnJ1bGVzLmFkZChuYW1lLCBzdHlsZXNbbmFtZV0pO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMucHJvY2VzcygpO1xuICB9XG4gIC8qKlxuICAgKiBBdHRhY2ggcmVuZGVyYWJsZSB0byB0aGUgcmVuZGVyIHRyZWUuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFN0eWxlU2hlZXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5hdHRhY2ggPSBmdW5jdGlvbiBhdHRhY2goKSB7XG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHJldHVybiB0aGlzO1xuICAgIGlmICh0aGlzLnJlbmRlcmVyKSB0aGlzLnJlbmRlcmVyLmF0dGFjaCgpO1xuICAgIHRoaXMuYXR0YWNoZWQgPSB0cnVlOyAvLyBPcmRlciBpcyBpbXBvcnRhbnQsIGJlY2F1c2Ugd2UgY2FuJ3QgdXNlIGluc2VydFJ1bGUgQVBJIGlmIHN0eWxlIGVsZW1lbnQgaXMgbm90IGF0dGFjaGVkLlxuXG4gICAgaWYgKCF0aGlzLmRlcGxveWVkKSB0aGlzLmRlcGxveSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgcmVuZGVyYWJsZSBmcm9tIHJlbmRlciB0cmVlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZXRhY2ggPSBmdW5jdGlvbiBkZXRhY2goKSB7XG4gICAgaWYgKCF0aGlzLmF0dGFjaGVkKSByZXR1cm4gdGhpcztcbiAgICBpZiAodGhpcy5yZW5kZXJlcikgdGhpcy5yZW5kZXJlci5kZXRhY2goKTtcbiAgICB0aGlzLmF0dGFjaGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIHJ1bGUgdG8gdGhlIGN1cnJlbnQgc3R5bGVzaGVldC5cbiAgICogV2lsbCBpbnNlcnQgYSBydWxlIGFsc28gYWZ0ZXIgdGhlIHN0eWxlc2hlZXQgaGFzIGJlZW4gcmVuZGVyZWQgZmlyc3QgdGltZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uYWRkUnVsZSA9IGZ1bmN0aW9uIGFkZFJ1bGUobmFtZSwgZGVjbCwgb3B0aW9ucykge1xuICAgIHZhciBxdWV1ZSA9IHRoaXMucXVldWU7IC8vIFBsdWdpbnMgY2FuIGNyZWF0ZSBydWxlcy5cbiAgICAvLyBJbiBvcmRlciB0byBwcmVzZXJ2ZSB0aGUgcmlnaHQgb3JkZXIsIHdlIG5lZWQgdG8gcXVldWUgYWxsIGAuYWRkUnVsZWAgY2FsbHMsXG4gICAgLy8gd2hpY2ggaGFwcGVuIGFmdGVyIHRoZSBmaXJzdCBgcnVsZXMuYWRkKClgIGNhbGwuXG5cbiAgICBpZiAodGhpcy5hdHRhY2hlZCAmJiAhcXVldWUpIHRoaXMucXVldWUgPSBbXTtcbiAgICB2YXIgcnVsZSA9IHRoaXMucnVsZXMuYWRkKG5hbWUsIGRlY2wsIG9wdGlvbnMpO1xuICAgIGlmICghcnVsZSkgcmV0dXJuIG51bGw7XG4gICAgdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zLm9uUHJvY2Vzc1J1bGUocnVsZSk7XG5cbiAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgaWYgKCF0aGlzLmRlcGxveWVkKSByZXR1cm4gcnVsZTsgLy8gRG9uJ3QgaW5zZXJ0IHJ1bGUgZGlyZWN0bHkgaWYgdGhlcmUgaXMgbm8gc3RyaW5naWZpZWQgdmVyc2lvbiB5ZXQuXG4gICAgICAvLyBJdCB3aWxsIGJlIGluc2VydGVkIGFsbCB0b2dldGhlciB3aGVuIC5hdHRhY2ggaXMgY2FsbGVkLlxuXG4gICAgICBpZiAocXVldWUpIHF1ZXVlLnB1c2gocnVsZSk7ZWxzZSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0UnVsZShydWxlKTtcblxuICAgICAgICBpZiAodGhpcy5xdWV1ZSkge1xuICAgICAgICAgIHRoaXMucXVldWUuZm9yRWFjaCh0aGlzLmluc2VydFJ1bGUsIHRoaXMpO1xuICAgICAgICAgIHRoaXMucXVldWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBydWxlO1xuICAgIH0gLy8gV2UgY2FuJ3QgYWRkIHJ1bGVzIHRvIGEgZGV0YWNoZWQgc3R5bGUgbm9kZS5cbiAgICAvLyBXZSB3aWxsIHJlZGVwbG95IHRoZSBzaGVldCBvbmNlIHVzZXIgd2lsbCBhdHRhY2ggaXQuXG5cblxuICAgIHRoaXMuZGVwbG95ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuICAvKipcbiAgICogUmVwbGFjZSBhIHJ1bGUgaW4gdGhlIGN1cnJlbnQgc3R5bGVzaGVldC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVwbGFjZVJ1bGUgPSBmdW5jdGlvbiByZXBsYWNlUnVsZShuYW1lT3JTZWxlY3RvciwgZGVjbCwgb3B0aW9ucykge1xuICAgIHZhciBvbGRSdWxlID0gdGhpcy5ydWxlcy5nZXQobmFtZU9yU2VsZWN0b3IpO1xuICAgIGlmICghb2xkUnVsZSkgcmV0dXJuIHRoaXMuYWRkUnVsZShuYW1lT3JTZWxlY3RvciwgZGVjbCwgb3B0aW9ucyk7XG4gICAgdmFyIG5ld1J1bGUgPSB0aGlzLnJ1bGVzLnJlcGxhY2UobmFtZU9yU2VsZWN0b3IsIGRlY2wsIG9wdGlvbnMpO1xuXG4gICAgaWYgKG5ld1J1bGUpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5qc3MucGx1Z2lucy5vblByb2Nlc3NSdWxlKG5ld1J1bGUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmF0dGFjaGVkKSB7XG4gICAgICBpZiAoIXRoaXMuZGVwbG95ZWQpIHJldHVybiBuZXdSdWxlOyAvLyBEb24ndCByZXBsYWNlIC8gZGVsZXRlIHJ1bGUgZGlyZWN0bHkgaWYgdGhlcmUgaXMgbm8gc3RyaW5naWZpZWQgdmVyc2lvbiB5ZXQuXG4gICAgICAvLyBJdCB3aWxsIGJlIGluc2VydGVkIGFsbCB0b2dldGhlciB3aGVuIC5hdHRhY2ggaXMgY2FsbGVkLlxuXG4gICAgICBpZiAodGhpcy5yZW5kZXJlcikge1xuICAgICAgICBpZiAoIW5ld1J1bGUpIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLmRlbGV0ZVJ1bGUob2xkUnVsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAob2xkUnVsZS5yZW5kZXJhYmxlKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlci5yZXBsYWNlUnVsZShvbGRSdWxlLnJlbmRlcmFibGUsIG5ld1J1bGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdSdWxlO1xuICAgIH0gLy8gV2UgY2FuJ3QgcmVwbGFjZSBydWxlcyB0byBhIGRldGFjaGVkIHN0eWxlIG5vZGUuXG4gICAgLy8gV2Ugd2lsbCByZWRlcGxveSB0aGUgc2hlZXQgb25jZSB1c2VyIHdpbGwgYXR0YWNoIGl0LlxuXG5cbiAgICB0aGlzLmRlcGxveWVkID0gZmFsc2U7XG4gICAgcmV0dXJuIG5ld1J1bGU7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBydWxlIGludG8gdGhlIFN0eWxlU2hlZXRcbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5zZXJ0UnVsZSA9IGZ1bmN0aW9uIGluc2VydFJ1bGUocnVsZSkge1xuICAgIGlmICh0aGlzLnJlbmRlcmVyKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLmluc2VydFJ1bGUocnVsZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIGFkZCBydWxlcy5cbiAgICogV2lsbCByZW5kZXIgYWxzbyBhZnRlciBTdHlsZSBTaGVldCB3YXMgcmVuZGVyZWQgdGhlIGZpcnN0IHRpbWUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmFkZFJ1bGVzID0gZnVuY3Rpb24gYWRkUnVsZXMoc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgdmFyIGFkZGVkID0gW107XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHN0eWxlcykge1xuICAgICAgdmFyIHJ1bGUgPSB0aGlzLmFkZFJ1bGUobmFtZSwgc3R5bGVzW25hbWVdLCBvcHRpb25zKTtcbiAgICAgIGlmIChydWxlKSBhZGRlZC5wdXNoKHJ1bGUpO1xuICAgIH1cblxuICAgIHJldHVybiBhZGRlZDtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgcnVsZSBieSBuYW1lIG9yIHNlbGVjdG9yLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5nZXRSdWxlID0gZnVuY3Rpb24gZ2V0UnVsZShuYW1lT3JTZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzLmdldChuYW1lT3JTZWxlY3Rvcik7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBhIHJ1bGUgYnkgbmFtZS5cbiAgICogUmV0dXJucyBgdHJ1ZWA6IGlmIHJ1bGUgaGFzIGJlZW4gZGVsZXRlZCBmcm9tIHRoZSBET00uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRlbGV0ZVJ1bGUgPSBmdW5jdGlvbiBkZWxldGVSdWxlKG5hbWUpIHtcbiAgICB2YXIgcnVsZSA9IHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JyA/IG5hbWUgOiB0aGlzLnJ1bGVzLmdldChuYW1lKTtcblxuICAgIGlmICghcnVsZSB8fCAvLyBTdHlsZSBzaGVldCB3YXMgY3JlYXRlZCB3aXRob3V0IGxpbms6IHRydWUgYW5kIGF0dGFjaGVkLCBpbiB0aGlzIGNhc2Ugd2VcbiAgICAvLyB3b24ndCBiZSBhYmxlIHRvIHJlbW92ZSB0aGUgQ1NTIHJ1bGUgZnJvbSB0aGUgRE9NLlxuICAgIHRoaXMuYXR0YWNoZWQgJiYgIXJ1bGUucmVuZGVyYWJsZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMucmVtb3ZlKHJ1bGUpO1xuXG4gICAgaWYgKHRoaXMuYXR0YWNoZWQgJiYgcnVsZS5yZW5kZXJhYmxlICYmIHRoaXMucmVuZGVyZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmRlbGV0ZVJ1bGUocnVsZS5yZW5kZXJhYmxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogR2V0IGluZGV4IG9mIGEgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YocnVsZSkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzLmluZGV4T2YocnVsZSk7XG4gIH1cbiAgLyoqXG4gICAqIERlcGxveSBwdXJlIENTUyBzdHJpbmcgdG8gYSByZW5kZXJhYmxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZXBsb3kgPSBmdW5jdGlvbiBkZXBsb3koKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyZXIpIHRoaXMucmVuZGVyZXIuZGVwbG95KCk7XG4gICAgdGhpcy5kZXBsb3llZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgZnVuY3Rpb24gdmFsdWVzIHdpdGggYSBuZXcgZGF0YS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHZhciBfdGhpcyRydWxlcztcblxuICAgIChfdGhpcyRydWxlcyA9IHRoaXMucnVsZXMpLnVwZGF0ZS5hcHBseShfdGhpcyRydWxlcywgYXJndW1lbnRzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgc2luZ2xlIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVwZGF0ZU9uZSA9IGZ1bmN0aW9uIHVwZGF0ZU9uZShydWxlLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgdGhpcy5ydWxlcy51cGRhdGVPbmUocnVsZSwgZGF0YSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgcnVsZXMgdG8gYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy50b1N0cmluZyhvcHRpb25zKTtcbiAgfTtcblxuICByZXR1cm4gU3R5bGVTaGVldDtcbn0oKTtcblxudmFyIFBsdWdpbnNSZWdpc3RyeSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBsdWdpbnNSZWdpc3RyeSgpIHtcbiAgICB0aGlzLnBsdWdpbnMgPSB7XG4gICAgICBpbnRlcm5hbDogW10sXG4gICAgICBleHRlcm5hbDogW11cbiAgICB9O1xuICAgIHRoaXMucmVnaXN0cnkgPSB7fTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQbHVnaW5zUmVnaXN0cnkucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBDYWxsIGBvbkNyZWF0ZVJ1bGVgIGhvb2tzIGFuZCByZXR1cm4gYW4gb2JqZWN0IGlmIHJldHVybmVkIGJ5IGEgaG9vay5cbiAgICovXG4gIF9wcm90by5vbkNyZWF0ZVJ1bGUgPSBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUobmFtZSwgZGVjbCwgb3B0aW9ucykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5vbkNyZWF0ZVJ1bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBydWxlID0gdGhpcy5yZWdpc3RyeS5vbkNyZWF0ZVJ1bGVbaV0obmFtZSwgZGVjbCwgb3B0aW9ucyk7XG4gICAgICBpZiAocnVsZSkgcmV0dXJuIHJ1bGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYG9uUHJvY2Vzc1J1bGVgIGhvb2tzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5vblByb2Nlc3NSdWxlID0gZnVuY3Rpb24gb25Qcm9jZXNzUnVsZShydWxlKSB7XG4gICAgaWYgKHJ1bGUuaXNQcm9jZXNzZWQpIHJldHVybjtcbiAgICB2YXIgc2hlZXQgPSBydWxlLm9wdGlvbnMuc2hlZXQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVnaXN0cnkub25Qcm9jZXNzUnVsZS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5yZWdpc3RyeS5vblByb2Nlc3NSdWxlW2ldKHJ1bGUsIHNoZWV0KTtcbiAgICB9XG5cbiAgICBpZiAocnVsZS5zdHlsZSkgdGhpcy5vblByb2Nlc3NTdHlsZShydWxlLnN0eWxlLCBydWxlLCBzaGVldCk7XG4gICAgcnVsZS5pc1Byb2Nlc3NlZCA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYG9uUHJvY2Vzc1N0eWxlYCBob29rcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ub25Qcm9jZXNzU3R5bGUgPSBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSwgc2hlZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVnaXN0cnkub25Qcm9jZXNzU3R5bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJ1bGUuc3R5bGUgPSB0aGlzLnJlZ2lzdHJ5Lm9uUHJvY2Vzc1N0eWxlW2ldKHJ1bGUuc3R5bGUsIHJ1bGUsIHNoZWV0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYG9uUHJvY2Vzc1NoZWV0YCBob29rcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ub25Qcm9jZXNzU2hlZXQgPSBmdW5jdGlvbiBvblByb2Nlc3NTaGVldChzaGVldCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5vblByb2Nlc3NTaGVldC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5yZWdpc3RyeS5vblByb2Nlc3NTaGVldFtpXShzaGVldCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYWxsIGBvblVwZGF0ZWAgaG9va3MuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm9uVXBkYXRlID0gZnVuY3Rpb24gb25VcGRhdGUoZGF0YSwgcnVsZSwgc2hlZXQsIG9wdGlvbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVnaXN0cnkub25VcGRhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMucmVnaXN0cnkub25VcGRhdGVbaV0oZGF0YSwgcnVsZSwgc2hlZXQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2FsbCBgb25DaGFuZ2VWYWx1ZWAgaG9va3MuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm9uQ2hhbmdlVmFsdWUgPSBmdW5jdGlvbiBvbkNoYW5nZVZhbHVlKHZhbHVlLCBwcm9wLCBydWxlKSB7XG4gICAgdmFyIHByb2Nlc3NlZFZhbHVlID0gdmFsdWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVnaXN0cnkub25DaGFuZ2VWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgcHJvY2Vzc2VkVmFsdWUgPSB0aGlzLnJlZ2lzdHJ5Lm9uQ2hhbmdlVmFsdWVbaV0ocHJvY2Vzc2VkVmFsdWUsIHByb3AsIHJ1bGUpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9jZXNzZWRWYWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBwbHVnaW4uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVzZSA9IGZ1bmN0aW9uIHVzZShuZXdQbHVnaW4sIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBxdWV1ZTogJ2V4dGVybmFsJ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgcGx1Z2lucyA9IHRoaXMucGx1Z2luc1tvcHRpb25zLnF1ZXVlXTsgLy8gQXZvaWRzIGFwcGx5aW5nIHNhbWUgcGx1Z2luIHR3aWNlLCBhdCBsZWFzdCBiYXNlZCBvbiByZWYuXG5cbiAgICBpZiAocGx1Z2lucy5pbmRleE9mKG5ld1BsdWdpbikgIT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGx1Z2lucy5wdXNoKG5ld1BsdWdpbik7XG4gICAgdGhpcy5yZWdpc3RyeSA9IFtdLmNvbmNhdCh0aGlzLnBsdWdpbnMuZXh0ZXJuYWwsIHRoaXMucGx1Z2lucy5pbnRlcm5hbCkucmVkdWNlKGZ1bmN0aW9uIChyZWdpc3RyeSwgcGx1Z2luKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHBsdWdpbikge1xuICAgICAgICBpZiAobmFtZSBpbiByZWdpc3RyeSkge1xuICAgICAgICAgIHJlZ2lzdHJ5W25hbWVdLnB1c2gocGx1Z2luW25hbWVdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIFVua25vd24gaG9vayBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLlwiKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVnaXN0cnk7XG4gICAgfSwge1xuICAgICAgb25DcmVhdGVSdWxlOiBbXSxcbiAgICAgIG9uUHJvY2Vzc1J1bGU6IFtdLFxuICAgICAgb25Qcm9jZXNzU3R5bGU6IFtdLFxuICAgICAgb25Qcm9jZXNzU2hlZXQ6IFtdLFxuICAgICAgb25DaGFuZ2VWYWx1ZTogW10sXG4gICAgICBvblVwZGF0ZTogW11cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gUGx1Z2luc1JlZ2lzdHJ5O1xufSgpO1xuXG4vKipcbiAqIFNoZWV0cyByZWdpc3RyeSB0byBhY2Nlc3MgYWxsIGluc3RhbmNlcyBpbiBvbmUgcGxhY2UuXG4gKi9cblxudmFyIFNoZWV0c1JlZ2lzdHJ5ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2hlZXRzUmVnaXN0cnkoKSB7XG4gICAgdGhpcy5yZWdpc3RyeSA9IFtdO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNoZWV0c1JlZ2lzdHJ5LnByb3RvdHlwZTtcblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBTdHlsZSBTaGVldC5cbiAgICovXG4gIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQoc2hlZXQpIHtcbiAgICB2YXIgcmVnaXN0cnkgPSB0aGlzLnJlZ2lzdHJ5O1xuICAgIHZhciBpbmRleCA9IHNoZWV0Lm9wdGlvbnMuaW5kZXg7XG4gICAgaWYgKHJlZ2lzdHJ5LmluZGV4T2Yoc2hlZXQpICE9PSAtMSkgcmV0dXJuO1xuXG4gICAgaWYgKHJlZ2lzdHJ5Lmxlbmd0aCA9PT0gMCB8fCBpbmRleCA+PSB0aGlzLmluZGV4KSB7XG4gICAgICByZWdpc3RyeS5wdXNoKHNoZWV0KTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZpbmQgYSBwb3NpdGlvbi5cblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyeS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlZ2lzdHJ5W2ldLm9wdGlvbnMuaW5kZXggPiBpbmRleCkge1xuICAgICAgICByZWdpc3RyeS5zcGxpY2UoaSwgMCwgc2hlZXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXNldCB0aGUgcmVnaXN0cnkuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdGhpcy5yZWdpc3RyeSA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgYSBTdHlsZSBTaGVldC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKHNoZWV0KSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5yZWdpc3RyeS5pbmRleE9mKHNoZWV0KTtcbiAgICB0aGlzLnJlZ2lzdHJ5LnNwbGljZShpbmRleCwgMSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnQgYWxsIGF0dGFjaGVkIHNoZWV0cyB0byBhIENTUyBzdHJpbmcuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoX3RlbXApIHtcbiAgICB2YXIgX3JlZiA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wLFxuICAgICAgICBhdHRhY2hlZCA9IF9yZWYuYXR0YWNoZWQsXG4gICAgICAgIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBbXCJhdHRhY2hlZFwiXSk7XG5cbiAgICB2YXIgX2dldFdoaXRlc3BhY2VTeW1ib2xzID0gZ2V0V2hpdGVzcGFjZVN5bWJvbHMob3B0aW9ucyksXG4gICAgICAgIGxpbmVicmVhayA9IF9nZXRXaGl0ZXNwYWNlU3ltYm9scy5saW5lYnJlYWs7XG5cbiAgICB2YXIgY3NzID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVnaXN0cnkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzaGVldCA9IHRoaXMucmVnaXN0cnlbaV07XG5cbiAgICAgIGlmIChhdHRhY2hlZCAhPSBudWxsICYmIHNoZWV0LmF0dGFjaGVkICE9PSBhdHRhY2hlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNzcykgY3NzICs9IGxpbmVicmVhaztcbiAgICAgIGNzcyArPSBzaGVldC50b1N0cmluZyhvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3NzO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhTaGVldHNSZWdpc3RyeSwgW3tcbiAgICBrZXk6IFwiaW5kZXhcIixcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgaGlnaGVzdCBpbmRleCBudW1iZXIuXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWdpc3RyeS5sZW5ndGggPT09IDAgPyAwIDogdGhpcy5yZWdpc3RyeVt0aGlzLnJlZ2lzdHJ5Lmxlbmd0aCAtIDFdLm9wdGlvbnMuaW5kZXg7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNoZWV0c1JlZ2lzdHJ5O1xufSgpO1xuXG4vKipcbiAqIFRoaXMgaXMgYSBnbG9iYWwgc2hlZXRzIHJlZ2lzdHJ5LiBPbmx5IERvbVJlbmRlcmVyIHdpbGwgYWRkIHNoZWV0cyB0byBpdC5cbiAqIE9uIHRoZSBzZXJ2ZXIgb25lIHNob3VsZCB1c2UgYW4gb3duIFNoZWV0c1JlZ2lzdHJ5IGluc3RhbmNlIGFuZCBhZGQgdGhlXG4gKiBzaGVldHMgdG8gaXQsIGJlY2F1c2UgeW91IG5lZWQgdG8gbWFrZSBzdXJlIHRvIGNyZWF0ZSBhIG5ldyByZWdpc3RyeSBmb3JcbiAqIGVhY2ggcmVxdWVzdCBpbiBvcmRlciB0byBub3QgbGVhayBzaGVldHMgYWNyb3NzIHJlcXVlc3RzLlxuICovXG5cbnZhciBzaGVldHMgPSBuZXcgU2hlZXRzUmVnaXN0cnkoKTtcblxuLyogZXNsaW50LWRpc2FibGUgKi9cblxuLyoqXG4gKiBOb3cgdGhhdCBgZ2xvYmFsVGhpc2AgaXMgYXZhaWxhYmxlIG9uIG1vc3QgcGxhdGZvcm1zXG4gKiAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvZ2xvYmFsVGhpcyNicm93c2VyX2NvbXBhdGliaWxpdHkpXG4gKiB3ZSBjaGVjayBmb3IgYGdsb2JhbFRoaXNgIGZpcnN0LiBgZ2xvYmFsVGhpc2AgaXMgbmVjZXNzYXJ5IGZvciBqc3NcbiAqIHRvIHJ1biBpbiBBZ29yaWMncyBzZWN1cmUgdmVyc2lvbiBvZiBKYXZhU2NyaXB0IChTRVMpLiBVbmRlciBTRVMsXG4gKiBgZ2xvYmFsVGhpc2AgZXhpc3RzLCBidXQgYHdpbmRvd2AsIGBzZWxmYCwgYW5kIGBGdW5jdGlvbigncmV0dXJuXG4gKiB0aGlzJykoKWAgYXJlIGFsbCB1bmRlZmluZWQgZm9yIHNlY3VyaXR5IHJlYXNvbnMuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbiAqL1xudmFyIGdsb2JhbFRoaXMkMSA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PT0gTWF0aCA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxudmFyIG5zID0gJzJmMWFjYzZjM2E2MDZiMDgyZTVlZWY1ZTU0NDE0ZmZiJztcbmlmIChnbG9iYWxUaGlzJDFbbnNdID09IG51bGwpIGdsb2JhbFRoaXMkMVtuc10gPSAwOyAvLyBCdW5kbGUgbWF5IGNvbnRhaW4gbXVsdGlwbGUgSlNTIHZlcnNpb25zIGF0IHRoZSBzYW1lIHRpbWUuIEluIG9yZGVyIHRvIGlkZW50aWZ5XG4vLyB0aGUgY3VycmVudCB2ZXJzaW9uIHdpdGgganVzdCBvbmUgc2hvcnQgbnVtYmVyIGFuZCB1c2UgaXQgZm9yIGNsYXNzZXMgZ2VuZXJhdGlvblxuLy8gd2UgdXNlIGEgY291bnRlci4gQWxzbyBpdCBpcyBtb3JlIGFjY3VyYXRlLCBiZWNhdXNlIHVzZXIgY2FuIG1hbnVhbGx5IHJlZXZhbHVhdGVcbi8vIHRoZSBtb2R1bGUuXG5cbnZhciBtb2R1bGVJZCA9IGdsb2JhbFRoaXMkMVtuc10rKztcblxudmFyIG1heFJ1bGVzID0gMWUxMDtcbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGdlbmVyYXRlcyB1bmlxdWUgY2xhc3MgbmFtZXMgYmFzZWQgb24gY291bnRlcnMuXG4gKiBXaGVuIG5ldyBnZW5lcmF0b3IgZnVuY3Rpb24gaXMgY3JlYXRlZCwgcnVsZSBjb3VudGVyIGlzIHJlc2V0ZWQuXG4gKiBXZSBuZWVkIHRvIHJlc2V0IHRoZSBydWxlIGNvdW50ZXIgZm9yIFNTUiBmb3IgZWFjaCByZXF1ZXN0LlxuICovXG5cbnZhciBjcmVhdGVHZW5lcmF0ZUlkID0gZnVuY3Rpb24gY3JlYXRlR2VuZXJhdGVJZChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgcnVsZUNvdW50ZXIgPSAwO1xuXG4gIHZhciBnZW5lcmF0ZUlkID0gZnVuY3Rpb24gZ2VuZXJhdGVJZChydWxlLCBzaGVldCkge1xuICAgIHJ1bGVDb3VudGVyICs9IDE7XG5cbiAgICBpZiAocnVsZUNvdW50ZXIgPiBtYXhSdWxlcykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBZb3UgbWlnaHQgaGF2ZSBhIG1lbW9yeSBsZWFrLiBSdWxlIGNvdW50ZXIgaXMgYXQgXCIgKyBydWxlQ291bnRlciArIFwiLlwiKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB2YXIganNzSWQgPSAnJztcbiAgICB2YXIgcHJlZml4ID0gJyc7XG5cbiAgICBpZiAoc2hlZXQpIHtcbiAgICAgIGlmIChzaGVldC5vcHRpb25zLmNsYXNzTmFtZVByZWZpeCkge1xuICAgICAgICBwcmVmaXggPSBzaGVldC5vcHRpb25zLmNsYXNzTmFtZVByZWZpeDtcbiAgICAgIH1cblxuICAgICAgaWYgKHNoZWV0Lm9wdGlvbnMuanNzLmlkICE9IG51bGwpIHtcbiAgICAgICAganNzSWQgPSBTdHJpbmcoc2hlZXQub3B0aW9ucy5qc3MuaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm1pbmlmeSkge1xuICAgICAgLy8gVXNpbmcgXCJjXCIgYmVjYXVzZSBhIG51bWJlciBjYW4ndCBiZSB0aGUgZmlyc3QgY2hhciBpbiBhIGNsYXNzIG5hbWUuXG4gICAgICByZXR1cm4gXCJcIiArIChwcmVmaXggfHwgJ2MnKSArIG1vZHVsZUlkICsganNzSWQgKyBydWxlQ291bnRlcjtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJlZml4ICsgcnVsZS5rZXkgKyBcIi1cIiArIG1vZHVsZUlkICsgKGpzc0lkID8gXCItXCIgKyBqc3NJZCA6ICcnKSArIFwiLVwiICsgcnVsZUNvdW50ZXI7XG4gIH07XG5cbiAgcmV0dXJuIGdlbmVyYXRlSWQ7XG59O1xuXG4vKipcbiAqIENhY2hlIHRoZSB2YWx1ZSBmcm9tIHRoZSBmaXJzdCB0aW1lIGEgZnVuY3Rpb24gaXMgY2FsbGVkLlxuICovXG5cbnZhciBtZW1vaXplID0gZnVuY3Rpb24gbWVtb2l6ZShmbikge1xuICB2YXIgdmFsdWU7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF2YWx1ZSkgdmFsdWUgPSBmbigpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn07XG4vKipcbiAqIEdldCBhIHN0eWxlIHByb3BlcnR5IHZhbHVlLlxuICovXG5cblxudmFyIGdldFByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbiBnZXRQcm9wZXJ0eVZhbHVlKGNzc1J1bGUsIHByb3ApIHtcbiAgdHJ5IHtcbiAgICAvLyBTdXBwb3J0IENTU1RPTS5cbiAgICBpZiAoY3NzUnVsZS5hdHRyaWJ1dGVTdHlsZU1hcCkge1xuICAgICAgcmV0dXJuIGNzc1J1bGUuYXR0cmlidXRlU3R5bGVNYXAuZ2V0KHByb3ApO1xuICAgIH1cblxuICAgIHJldHVybiBjc3NSdWxlLnN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIElFIG1heSB0aHJvdyBpZiBwcm9wZXJ0eSBpcyB1bmtub3duLlxuICAgIHJldHVybiAnJztcbiAgfVxufTtcbi8qKlxuICogU2V0IGEgc3R5bGUgcHJvcGVydHkuXG4gKi9cblxuXG52YXIgc2V0UHJvcGVydHkgPSBmdW5jdGlvbiBzZXRQcm9wZXJ0eShjc3NSdWxlLCBwcm9wLCB2YWx1ZSkge1xuICB0cnkge1xuICAgIHZhciBjc3NWYWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBjc3NWYWx1ZSA9IHRvQ3NzVmFsdWUodmFsdWUpO1xuICAgIH0gLy8gU3VwcG9ydCBDU1NUT00uXG5cblxuICAgIGlmIChjc3NSdWxlLmF0dHJpYnV0ZVN0eWxlTWFwKSB7XG4gICAgICBjc3NSdWxlLmF0dHJpYnV0ZVN0eWxlTWFwLnNldChwcm9wLCBjc3NWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpbmRleE9mSW1wb3J0YW50RmxhZyA9IGNzc1ZhbHVlID8gY3NzVmFsdWUuaW5kZXhPZignIWltcG9ydGFudCcpIDogLTE7XG4gICAgICB2YXIgY3NzVmFsdWVXaXRob3V0SW1wb3J0YW50RmxhZyA9IGluZGV4T2ZJbXBvcnRhbnRGbGFnID4gLTEgPyBjc3NWYWx1ZS5zdWJzdHIoMCwgaW5kZXhPZkltcG9ydGFudEZsYWcgLSAxKSA6IGNzc1ZhbHVlO1xuICAgICAgY3NzUnVsZS5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCBjc3NWYWx1ZVdpdGhvdXRJbXBvcnRhbnRGbGFnLCBpbmRleE9mSW1wb3J0YW50RmxhZyA+IC0xID8gJ2ltcG9ydGFudCcgOiAnJyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBJRSBtYXkgdGhyb3cgaWYgcHJvcGVydHkgaXMgdW5rbm93bi5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbiAqIFJlbW92ZSBhIHN0eWxlIHByb3BlcnR5LlxuICovXG5cblxudmFyIHJlbW92ZVByb3BlcnR5ID0gZnVuY3Rpb24gcmVtb3ZlUHJvcGVydHkoY3NzUnVsZSwgcHJvcCkge1xuICB0cnkge1xuICAgIC8vIFN1cHBvcnQgQ1NTVE9NLlxuICAgIGlmIChjc3NSdWxlLmF0dHJpYnV0ZVN0eWxlTWFwKSB7XG4gICAgICBjc3NSdWxlLmF0dHJpYnV0ZVN0eWxlTWFwLmRlbGV0ZShwcm9wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3NzUnVsZS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gRE9NRXhjZXB0aW9uIFxcXCJcIiArIGVyci5tZXNzYWdlICsgXCJcXFwiIHdhcyB0aHJvd24uIFRyaWVkIHRvIHJlbW92ZSBwcm9wZXJ0eSBcXFwiXCIgKyBwcm9wICsgXCJcXFwiLlwiKSA6IHZvaWQgMDtcbiAgfVxufTtcbi8qKlxuICogU2V0IHRoZSBzZWxlY3Rvci5cbiAqL1xuXG5cbnZhciBzZXRTZWxlY3RvciA9IGZ1bmN0aW9uIHNldFNlbGVjdG9yKGNzc1J1bGUsIHNlbGVjdG9yVGV4dCkge1xuICBjc3NSdWxlLnNlbGVjdG9yVGV4dCA9IHNlbGVjdG9yVGV4dDsgLy8gUmV0dXJuIGZhbHNlIGlmIHNldHRlciB3YXMgbm90IHN1Y2Nlc3NmdWwuXG4gIC8vIEN1cnJlbnRseSB3b3JrcyBpbiBjaHJvbWUgb25seS5cblxuICByZXR1cm4gY3NzUnVsZS5zZWxlY3RvclRleHQgPT09IHNlbGVjdG9yVGV4dDtcbn07XG4vKipcbiAqIEdldHMgdGhlIGBoZWFkYCBlbGVtZW50IHVwb24gdGhlIGZpcnN0IGNhbGwgYW5kIGNhY2hlcyBpdC5cbiAqIFdlIGFzc3VtZSBpdCBjYW4ndCBiZSBudWxsLlxuICovXG5cblxudmFyIGdldEhlYWQgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2hlYWQnKTtcbn0pO1xuLyoqXG4gKiBGaW5kIGF0dGFjaGVkIHNoZWV0IHdpdGggYW4gaW5kZXggaGlnaGVyIHRoYW4gdGhlIHBhc3NlZCBvbmUuXG4gKi9cblxuZnVuY3Rpb24gZmluZEhpZ2hlclNoZWV0KHJlZ2lzdHJ5LCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0cnkubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2hlZXQgPSByZWdpc3RyeVtpXTtcblxuICAgIGlmIChzaGVldC5hdHRhY2hlZCAmJiBzaGVldC5vcHRpb25zLmluZGV4ID4gb3B0aW9ucy5pbmRleCAmJiBzaGVldC5vcHRpb25zLmluc2VydGlvblBvaW50ID09PSBvcHRpb25zLmluc2VydGlvblBvaW50KSB7XG4gICAgICByZXR1cm4gc2hlZXQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEZpbmQgYXR0YWNoZWQgc2hlZXQgd2l0aCB0aGUgaGlnaGVzdCBpbmRleC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGZpbmRIaWdoZXN0U2hlZXQocmVnaXN0cnksIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IHJlZ2lzdHJ5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHNoZWV0ID0gcmVnaXN0cnlbaV07XG5cbiAgICBpZiAoc2hlZXQuYXR0YWNoZWQgJiYgc2hlZXQub3B0aW9ucy5pbnNlcnRpb25Qb2ludCA9PT0gb3B0aW9ucy5pbnNlcnRpb25Qb2ludCkge1xuICAgICAgcmV0dXJuIHNoZWV0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBGaW5kIGEgY29tbWVudCB3aXRoIFwianNzXCIgaW5zaWRlLlxuICovXG5cblxuZnVuY3Rpb24gZmluZENvbW1lbnROb2RlKHRleHQpIHtcbiAgdmFyIGhlYWQgPSBnZXRIZWFkKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWFkLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IGhlYWQuY2hpbGROb2Rlc1tpXTtcblxuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSA4ICYmIG5vZGUubm9kZVZhbHVlLnRyaW0oKSA9PT0gdGV4dCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEZpbmQgYSBub2RlIGJlZm9yZSB3aGljaCB3ZSBjYW4gaW5zZXJ0IHRoZSBzaGVldC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGZpbmRQcmV2Tm9kZShvcHRpb25zKSB7XG4gIHZhciByZWdpc3RyeSA9IHNoZWV0cy5yZWdpc3RyeTtcblxuICBpZiAocmVnaXN0cnkubGVuZ3RoID4gMCkge1xuICAgIC8vIFRyeSB0byBpbnNlcnQgYmVmb3JlIHRoZSBuZXh0IGhpZ2hlciBzaGVldC5cbiAgICB2YXIgc2hlZXQgPSBmaW5kSGlnaGVyU2hlZXQocmVnaXN0cnksIG9wdGlvbnMpO1xuXG4gICAgaWYgKHNoZWV0ICYmIHNoZWV0LnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXJlbnQ6IHNoZWV0LnJlbmRlcmVyLmVsZW1lbnQucGFyZW50Tm9kZSxcbiAgICAgICAgbm9kZTogc2hlZXQucmVuZGVyZXIuZWxlbWVudFxuICAgICAgfTtcbiAgICB9IC8vIE90aGVyd2lzZSBpbnNlcnQgYWZ0ZXIgdGhlIGxhc3QgYXR0YWNoZWQuXG5cblxuICAgIHNoZWV0ID0gZmluZEhpZ2hlc3RTaGVldChyZWdpc3RyeSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoc2hlZXQgJiYgc2hlZXQucmVuZGVyZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhcmVudDogc2hlZXQucmVuZGVyZXIuZWxlbWVudC5wYXJlbnROb2RlLFxuICAgICAgICBub2RlOiBzaGVldC5yZW5kZXJlci5lbGVtZW50Lm5leHRTaWJsaW5nXG4gICAgICB9O1xuICAgIH1cbiAgfSAvLyBUcnkgdG8gZmluZCBhIGNvbW1lbnQgcGxhY2Vob2xkZXIgaWYgcmVnaXN0cnkgaXMgZW1wdHkuXG5cblxuICB2YXIgaW5zZXJ0aW9uUG9pbnQgPSBvcHRpb25zLmluc2VydGlvblBvaW50O1xuXG4gIGlmIChpbnNlcnRpb25Qb2ludCAmJiB0eXBlb2YgaW5zZXJ0aW9uUG9pbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGNvbW1lbnQgPSBmaW5kQ29tbWVudE5vZGUoaW5zZXJ0aW9uUG9pbnQpO1xuXG4gICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhcmVudDogY29tbWVudC5wYXJlbnROb2RlLFxuICAgICAgICBub2RlOiBjb21tZW50Lm5leHRTaWJsaW5nXG4gICAgICB9O1xuICAgIH0gLy8gSWYgdXNlciBzcGVjaWZpZXMgYW4gaW5zZXJ0aW9uIHBvaW50IGFuZCBpdCBjYW4ndCBiZSBmb3VuZCBpbiB0aGUgZG9jdW1lbnQgLVxuICAgIC8vIGJhZCBzcGVjaWZpY2l0eSBpc3N1ZXMgbWF5IGFwcGVhci5cblxuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgXCJbSlNTXSBJbnNlcnRpb24gcG9pbnQgXFxcIlwiICsgaW5zZXJ0aW9uUG9pbnQgKyBcIlxcXCIgbm90IGZvdW5kLlwiKSA6IHZvaWQgMDtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogSW5zZXJ0IHN0eWxlIGVsZW1lbnQgaW50byB0aGUgRE9NLlxuICovXG5cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGUoc3R5bGUsIG9wdGlvbnMpIHtcbiAgdmFyIGluc2VydGlvblBvaW50ID0gb3B0aW9ucy5pbnNlcnRpb25Qb2ludDtcbiAgdmFyIG5leHROb2RlID0gZmluZFByZXZOb2RlKG9wdGlvbnMpO1xuXG4gIGlmIChuZXh0Tm9kZSAhPT0gZmFsc2UgJiYgbmV4dE5vZGUucGFyZW50KSB7XG4gICAgbmV4dE5vZGUucGFyZW50Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dE5vZGUubm9kZSk7XG4gICAgcmV0dXJuO1xuICB9IC8vIFdvcmtzIHdpdGggaWZyYW1lcyBhbmQgYW55IG5vZGUgdHlwZXMuXG5cblxuICBpZiAoaW5zZXJ0aW9uUG9pbnQgJiYgdHlwZW9mIGluc2VydGlvblBvaW50Lm5vZGVUeXBlID09PSAnbnVtYmVyJykge1xuICAgIHZhciBpbnNlcnRpb25Qb2ludEVsZW1lbnQgPSBpbnNlcnRpb25Qb2ludDtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IGluc2VydGlvblBvaW50RWxlbWVudC5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLmluc2VydEJlZm9yZShzdHlsZSwgaW5zZXJ0aW9uUG9pbnRFbGVtZW50Lm5leHRTaWJsaW5nKTtlbHNlIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsICdbSlNTXSBJbnNlcnRpb24gcG9pbnQgaXMgbm90IGluIHRoZSBET00uJykgOiB2b2lkIDA7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZ2V0SGVhZCgpLmFwcGVuZENoaWxkKHN0eWxlKTtcbn1cbi8qKlxuICogUmVhZCBqc3Mgbm9uY2Ugc2V0dGluZyBmcm9tIHRoZSBwYWdlIGlmIHRoZSB1c2VyIGhhcyBzZXQgaXQuXG4gKi9cblxuXG52YXIgZ2V0Tm9uY2UgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW3Byb3BlcnR5PVwiY3NwLW5vbmNlXCJdJyk7XG4gIHJldHVybiBub2RlID8gbm9kZS5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKSA6IG51bGw7XG59KTtcblxudmFyIF9pbnNlcnRSdWxlID0gZnVuY3Rpb24gaW5zZXJ0UnVsZShjb250YWluZXIsIHJ1bGUsIGluZGV4KSB7XG4gIHRyeSB7XG4gICAgaWYgKCdpbnNlcnRSdWxlJyBpbiBjb250YWluZXIpIHtcbiAgICAgIGNvbnRhaW5lci5pbnNlcnRSdWxlKHJ1bGUsIGluZGV4KTtcbiAgICB9IC8vIEtleWZyYW1lcyBydWxlLlxuICAgIGVsc2UgaWYgKCdhcHBlbmRSdWxlJyBpbiBjb250YWluZXIpIHtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZFJ1bGUocnVsZSk7XG4gICAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gXCIgKyBlcnIubWVzc2FnZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRhaW5lci5jc3NSdWxlc1tpbmRleF07XG59O1xuXG52YXIgZ2V0VmFsaWRSdWxlSW5zZXJ0aW9uSW5kZXggPSBmdW5jdGlvbiBnZXRWYWxpZFJ1bGVJbnNlcnRpb25JbmRleChjb250YWluZXIsIGluZGV4KSB7XG4gIHZhciBtYXhJbmRleCA9IGNvbnRhaW5lci5jc3NSdWxlcy5sZW5ndGg7IC8vIEluIGNhc2UgcHJldmlvdXMgaW5zZXJ0aW9uIGZhaWxzLCBwYXNzZWQgaW5kZXggbWlnaHQgYmUgd3JvbmdcblxuICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCB8fCBpbmRleCA+IG1heEluZGV4KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgcmV0dXJuIG1heEluZGV4O1xuICB9XG5cbiAgcmV0dXJuIGluZGV4O1xufTtcblxudmFyIGNyZWF0ZVN0eWxlID0gZnVuY3Rpb24gY3JlYXRlU3R5bGUoKSB7XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7IC8vIFdpdGhvdXQgaXQsIElFIHdpbGwgaGF2ZSBhIGJyb2tlbiBzb3VyY2Ugb3JkZXIgc3BlY2lmaWNpdHkgaWYgd2VcbiAgLy8gaW5zZXJ0IHJ1bGVzIGFmdGVyIHdlIGluc2VydCB0aGUgc3R5bGUgdGFnLlxuICAvLyBJdCBzZWVtcyB0byBraWNrLW9mZiB0aGUgc291cmNlIG9yZGVyIHNwZWNpZmljaXR5IGFsZ29yaXRobS5cblxuICBlbC50ZXh0Q29udGVudCA9ICdcXG4nO1xuICByZXR1cm4gZWw7XG59O1xuXG52YXIgRG9tUmVuZGVyZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvLyBXaWxsIGJlIGVtcHR5IGlmIGxpbms6IHRydWUgb3B0aW9uIGlzIG5vdCBzZXQsIGJlY2F1c2VcbiAgLy8gaXQgaXMgb25seSBmb3IgdXNlIHRvZ2V0aGVyIHdpdGggaW5zZXJ0UnVsZSBBUEkuXG4gIGZ1bmN0aW9uIERvbVJlbmRlcmVyKHNoZWV0KSB7XG4gICAgdGhpcy5nZXRQcm9wZXJ0eVZhbHVlID0gZ2V0UHJvcGVydHlWYWx1ZTtcbiAgICB0aGlzLnNldFByb3BlcnR5ID0gc2V0UHJvcGVydHk7XG4gICAgdGhpcy5yZW1vdmVQcm9wZXJ0eSA9IHJlbW92ZVByb3BlcnR5O1xuICAgIHRoaXMuc2V0U2VsZWN0b3IgPSBzZXRTZWxlY3RvcjtcbiAgICB0aGlzLmhhc0luc2VydGVkUnVsZXMgPSBmYWxzZTtcbiAgICB0aGlzLmNzc1J1bGVzID0gW107XG4gICAgLy8gVGhlcmUgaXMgbm8gc2hlZXQgd2hlbiB0aGUgcmVuZGVyZXIgaXMgdXNlZCBmcm9tIGEgc3RhbmRhbG9uZSBTdHlsZVJ1bGUuXG4gICAgaWYgKHNoZWV0KSBzaGVldHMuYWRkKHNoZWV0KTtcbiAgICB0aGlzLnNoZWV0ID0gc2hlZXQ7XG5cbiAgICB2YXIgX3JlZiA9IHRoaXMuc2hlZXQgPyB0aGlzLnNoZWV0Lm9wdGlvbnMgOiB7fSxcbiAgICAgICAgbWVkaWEgPSBfcmVmLm1lZGlhLFxuICAgICAgICBtZXRhID0gX3JlZi5tZXRhLFxuICAgICAgICBlbGVtZW50ID0gX3JlZi5lbGVtZW50O1xuXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudCB8fCBjcmVhdGVTdHlsZSgpO1xuICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtanNzJywgJycpO1xuICAgIGlmIChtZWRpYSkgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSk7XG4gICAgaWYgKG1ldGEpIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbWV0YScsIG1ldGEpO1xuICAgIHZhciBub25jZSA9IGdldE5vbmNlKCk7XG4gICAgaWYgKG5vbmNlKSB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdub25jZScsIG5vbmNlKTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IHN0eWxlIGVsZW1lbnQgaW50byByZW5kZXIgdHJlZS5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gRG9tUmVuZGVyZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5hdHRhY2ggPSBmdW5jdGlvbiBhdHRhY2goKSB7XG4gICAgLy8gSW4gdGhlIGNhc2UgdGhlIGVsZW1lbnQgbm9kZSBpcyBleHRlcm5hbCBhbmQgaXQgaXMgYWxyZWFkeSBpbiB0aGUgRE9NLlxuICAgIGlmICh0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSB8fCAhdGhpcy5zaGVldCkgcmV0dXJuO1xuICAgIGluc2VydFN0eWxlKHRoaXMuZWxlbWVudCwgdGhpcy5zaGVldC5vcHRpb25zKTsgLy8gV2hlbiBydWxlcyBhcmUgaW5zZXJ0ZWQgdXNpbmcgYGluc2VydFJ1bGVgIEFQSSwgYWZ0ZXIgYHNoZWV0LmRldGFjaCgpLmF0dGFjaCgpYFxuICAgIC8vIG1vc3QgYnJvd3NlcnMgY3JlYXRlIGEgbmV3IENTU1N0eWxlU2hlZXQsIGV4Y2VwdCBvZiBhbGwgSUVzLlxuXG4gICAgdmFyIGRlcGxveWVkID0gQm9vbGVhbih0aGlzLnNoZWV0ICYmIHRoaXMuc2hlZXQuZGVwbG95ZWQpO1xuXG4gICAgaWYgKHRoaXMuaGFzSW5zZXJ0ZWRSdWxlcyAmJiBkZXBsb3llZCkge1xuICAgICAgdGhpcy5oYXNJbnNlcnRlZFJ1bGVzID0gZmFsc2U7XG4gICAgICB0aGlzLmRlcGxveSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIHN0eWxlIGVsZW1lbnQgZnJvbSByZW5kZXIgdHJlZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGV0YWNoID0gZnVuY3Rpb24gZGV0YWNoKCkge1xuICAgIGlmICghdGhpcy5zaGVldCkgcmV0dXJuO1xuICAgIHZhciBwYXJlbnROb2RlID0gdGhpcy5lbGVtZW50LnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudE5vZGUpIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KTsgLy8gSW4gdGhlIG1vc3QgYnJvd3NlcnMsIHJ1bGVzIGluc2VydGVkIHVzaW5nIGluc2VydFJ1bGUoKSBBUEkgd2lsbCBiZSBsb3N0IHdoZW4gc3R5bGUgZWxlbWVudCBpcyByZW1vdmVkLlxuICAgIC8vIFRob3VnaCBJRSB3aWxsIGtlZXAgdGhlbSBhbmQgd2UgbmVlZCBhIGNvbnNpc3RlbnQgYmVoYXZpb3IuXG5cbiAgICBpZiAodGhpcy5zaGVldC5vcHRpb25zLmxpbmspIHtcbiAgICAgIHRoaXMuY3NzUnVsZXMgPSBbXTtcbiAgICAgIHRoaXMuZWxlbWVudC50ZXh0Q29udGVudCA9ICdcXG4nO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5qZWN0IENTUyBzdHJpbmcgaW50byBlbGVtZW50LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZXBsb3kgPSBmdW5jdGlvbiBkZXBsb3koKSB7XG4gICAgdmFyIHNoZWV0ID0gdGhpcy5zaGVldDtcbiAgICBpZiAoIXNoZWV0KSByZXR1cm47XG5cbiAgICBpZiAoc2hlZXQub3B0aW9ucy5saW5rKSB7XG4gICAgICB0aGlzLmluc2VydFJ1bGVzKHNoZWV0LnJ1bGVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnQudGV4dENvbnRlbnQgPSBcIlxcblwiICsgc2hlZXQudG9TdHJpbmcoKSArIFwiXFxuXCI7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBSdWxlTGlzdCBpbnRvIGFuIGVsZW1lbnQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluc2VydFJ1bGVzID0gZnVuY3Rpb24gaW5zZXJ0UnVsZXMocnVsZXMsIG5hdGl2ZVBhcmVudCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMuaW5kZXgubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuaW5zZXJ0UnVsZShydWxlcy5pbmRleFtpXSwgaSwgbmF0aXZlUGFyZW50KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBhIHJ1bGUgaW50byBlbGVtZW50LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbnNlcnRSdWxlID0gZnVuY3Rpb24gaW5zZXJ0UnVsZShydWxlLCBpbmRleCwgbmF0aXZlUGFyZW50KSB7XG4gICAgaWYgKG5hdGl2ZVBhcmVudCA9PT0gdm9pZCAwKSB7XG4gICAgICBuYXRpdmVQYXJlbnQgPSB0aGlzLmVsZW1lbnQuc2hlZXQ7XG4gICAgfVxuXG4gICAgaWYgKHJ1bGUucnVsZXMpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBydWxlO1xuICAgICAgdmFyIGxhdGVzdE5hdGl2ZVBhcmVudCA9IG5hdGl2ZVBhcmVudDtcblxuICAgICAgaWYgKHJ1bGUudHlwZSA9PT0gJ2NvbmRpdGlvbmFsJyB8fCBydWxlLnR5cGUgPT09ICdrZXlmcmFtZXMnKSB7XG4gICAgICAgIHZhciBfaW5zZXJ0aW9uSW5kZXggPSBnZXRWYWxpZFJ1bGVJbnNlcnRpb25JbmRleChuYXRpdmVQYXJlbnQsIGluZGV4KTsgLy8gV2UgbmVlZCB0byByZW5kZXIgdGhlIGNvbnRhaW5lciB3aXRob3V0IGNoaWxkcmVuIGZpcnN0LlxuXG5cbiAgICAgICAgbGF0ZXN0TmF0aXZlUGFyZW50ID0gX2luc2VydFJ1bGUobmF0aXZlUGFyZW50LCBwYXJlbnQudG9TdHJpbmcoe1xuICAgICAgICAgIGNoaWxkcmVuOiBmYWxzZVxuICAgICAgICB9KSwgX2luc2VydGlvbkluZGV4KTtcblxuICAgICAgICBpZiAobGF0ZXN0TmF0aXZlUGFyZW50ID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVmQ3NzUnVsZShydWxlLCBfaW5zZXJ0aW9uSW5kZXgsIGxhdGVzdE5hdGl2ZVBhcmVudCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW5zZXJ0UnVsZXMocGFyZW50LnJ1bGVzLCBsYXRlc3ROYXRpdmVQYXJlbnQpO1xuICAgICAgcmV0dXJuIGxhdGVzdE5hdGl2ZVBhcmVudDtcbiAgICB9XG5cbiAgICB2YXIgcnVsZVN0ciA9IHJ1bGUudG9TdHJpbmcoKTtcbiAgICBpZiAoIXJ1bGVTdHIpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgaW5zZXJ0aW9uSW5kZXggPSBnZXRWYWxpZFJ1bGVJbnNlcnRpb25JbmRleChuYXRpdmVQYXJlbnQsIGluZGV4KTtcblxuICAgIHZhciBuYXRpdmVSdWxlID0gX2luc2VydFJ1bGUobmF0aXZlUGFyZW50LCBydWxlU3RyLCBpbnNlcnRpb25JbmRleCk7XG5cbiAgICBpZiAobmF0aXZlUnVsZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmhhc0luc2VydGVkUnVsZXMgPSB0cnVlO1xuICAgIHRoaXMucmVmQ3NzUnVsZShydWxlLCBpbnNlcnRpb25JbmRleCwgbmF0aXZlUnVsZSk7XG4gICAgcmV0dXJuIG5hdGl2ZVJ1bGU7XG4gIH07XG5cbiAgX3Byb3RvLnJlZkNzc1J1bGUgPSBmdW5jdGlvbiByZWZDc3NSdWxlKHJ1bGUsIGluZGV4LCBjc3NSdWxlKSB7XG4gICAgcnVsZS5yZW5kZXJhYmxlID0gY3NzUnVsZTsgLy8gV2Ugb25seSB3YW50IHRvIHJlZmVyZW5jZSB0aGUgdG9wIGxldmVsIHJ1bGVzLCBkZWxldGVSdWxlIEFQSSBkb2Vzbid0IHN1cHBvcnQgcmVtb3ZpbmcgbmVzdGVkIHJ1bGVzXG4gICAgLy8gbGlrZSBydWxlcyBpbnNpZGUgbWVkaWEgcXVlcmllcyBvciBrZXlmcmFtZXNcblxuICAgIGlmIChydWxlLm9wdGlvbnMucGFyZW50IGluc3RhbmNlb2YgU3R5bGVTaGVldCkge1xuICAgICAgdGhpcy5jc3NSdWxlcy5zcGxpY2UoaW5kZXgsIDAsIGNzc1J1bGUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGEgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGVsZXRlUnVsZSA9IGZ1bmN0aW9uIGRlbGV0ZVJ1bGUoY3NzUnVsZSkge1xuICAgIHZhciBzaGVldCA9IHRoaXMuZWxlbWVudC5zaGVldDtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YoY3NzUnVsZSk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICAgIHNoZWV0LmRlbGV0ZVJ1bGUoaW5kZXgpO1xuICAgIHRoaXMuY3NzUnVsZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogR2V0IGluZGV4IG9mIGEgQ1NTIFJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKGNzc1J1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5jc3NSdWxlcy5pbmRleE9mKGNzc1J1bGUpO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIG5ldyBDU1MgcnVsZSBhbmQgcmVwbGFjZSB0aGUgZXhpc3Rpbmcgb25lLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZXBsYWNlUnVsZSA9IGZ1bmN0aW9uIHJlcGxhY2VSdWxlKGNzc1J1bGUsIHJ1bGUpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YoY3NzUnVsZSk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICAgIHRoaXMuZWxlbWVudC5zaGVldC5kZWxldGVSdWxlKGluZGV4KTtcbiAgICB0aGlzLmNzc1J1bGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0UnVsZShydWxlLCBpbmRleCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhbGwgcnVsZXMgZWxlbWVudHMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldFJ1bGVzID0gZnVuY3Rpb24gZ2V0UnVsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5zaGVldC5jc3NSdWxlcztcbiAgfTtcblxuICByZXR1cm4gRG9tUmVuZGVyZXI7XG59KCk7XG5cbnZhciBpbnN0YW5jZUNvdW50ZXIgPSAwO1xuXG52YXIgSnNzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSnNzKG9wdGlvbnMpIHtcbiAgICB0aGlzLmlkID0gaW5zdGFuY2VDb3VudGVyKys7XG4gICAgdGhpcy52ZXJzaW9uID0gXCIxMC4xMC4wXCI7XG4gICAgdGhpcy5wbHVnaW5zID0gbmV3IFBsdWdpbnNSZWdpc3RyeSgpO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGlkOiB7XG4gICAgICAgIG1pbmlmeTogZmFsc2VcbiAgICAgIH0sXG4gICAgICBjcmVhdGVHZW5lcmF0ZUlkOiBjcmVhdGVHZW5lcmF0ZUlkLFxuICAgICAgUmVuZGVyZXI6IGlzSW5Ccm93c2VyID8gRG9tUmVuZGVyZXIgOiBudWxsLFxuICAgICAgcGx1Z2luczogW11cbiAgICB9O1xuICAgIHRoaXMuZ2VuZXJhdGVJZCA9IGNyZWF0ZUdlbmVyYXRlSWQoe1xuICAgICAgbWluaWZ5OiBmYWxzZVxuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnBsdWdpbnMudXNlKHBsdWdpbnNbaV0sIHtcbiAgICAgICAgcXVldWU6ICdpbnRlcm5hbCdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuc2V0dXAob3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFByZXBhcmVzIHZhcmlvdXMgb3B0aW9ucywgYXBwbGllcyBwbHVnaW5zLlxuICAgKiBTaG91bGQgbm90IGJlIHVzZWQgdHdpY2Ugb24gdGhlIHNhbWUgaW5zdGFuY2UsIGJlY2F1c2UgdGhlcmUgaXMgbm8gcGx1Z2luc1xuICAgKiBkZWR1cGxpY2F0aW9uIGxvZ2ljLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBKc3MucHJvdG90eXBlO1xuXG4gIF9wcm90by5zZXR1cCA9IGZ1bmN0aW9uIHNldHVwKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuY3JlYXRlR2VuZXJhdGVJZCkge1xuICAgICAgdGhpcy5vcHRpb25zLmNyZWF0ZUdlbmVyYXRlSWQgPSBvcHRpb25zLmNyZWF0ZUdlbmVyYXRlSWQ7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaWQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5pZCA9IF9leHRlbmRzKHt9LCB0aGlzLm9wdGlvbnMuaWQsIG9wdGlvbnMuaWQpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmNyZWF0ZUdlbmVyYXRlSWQgfHwgb3B0aW9ucy5pZCkge1xuICAgICAgdGhpcy5nZW5lcmF0ZUlkID0gdGhpcy5vcHRpb25zLmNyZWF0ZUdlbmVyYXRlSWQodGhpcy5vcHRpb25zLmlkKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbnNlcnRpb25Qb2ludCAhPSBudWxsKSB0aGlzLm9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQgPSBvcHRpb25zLmluc2VydGlvblBvaW50O1xuXG4gICAgaWYgKCdSZW5kZXJlcicgaW4gb3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zLlJlbmRlcmVyID0gb3B0aW9ucy5SZW5kZXJlcjtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG5cblxuICAgIGlmIChvcHRpb25zLnBsdWdpbnMpIHRoaXMudXNlLmFwcGx5KHRoaXMsIG9wdGlvbnMucGx1Z2lucyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIFN0eWxlIFNoZWV0LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5jcmVhdGVTdHlsZVNoZWV0ID0gZnVuY3Rpb24gY3JlYXRlU3R5bGVTaGVldChzdHlsZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgICAgaW5kZXggPSBfb3B0aW9ucy5pbmRleDtcblxuICAgIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSB7XG4gICAgICBpbmRleCA9IHNoZWV0cy5pbmRleCA9PT0gMCA/IDAgOiBzaGVldHMuaW5kZXggKyAxO1xuICAgIH1cblxuICAgIHZhciBzaGVldCA9IG5ldyBTdHlsZVNoZWV0KHN0eWxlcywgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIGpzczogdGhpcyxcbiAgICAgIGdlbmVyYXRlSWQ6IG9wdGlvbnMuZ2VuZXJhdGVJZCB8fCB0aGlzLmdlbmVyYXRlSWQsXG4gICAgICBpbnNlcnRpb25Qb2ludDogdGhpcy5vcHRpb25zLmluc2VydGlvblBvaW50LFxuICAgICAgUmVuZGVyZXI6IHRoaXMub3B0aW9ucy5SZW5kZXJlcixcbiAgICAgIGluZGV4OiBpbmRleFxuICAgIH0pKTtcbiAgICB0aGlzLnBsdWdpbnMub25Qcm9jZXNzU2hlZXQoc2hlZXQpO1xuICAgIHJldHVybiBzaGVldDtcbiAgfVxuICAvKipcbiAgICogRGV0YWNoIHRoZSBTdHlsZSBTaGVldCBhbmQgcmVtb3ZlIGl0IGZyb20gdGhlIHJlZ2lzdHJ5LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZW1vdmVTdHlsZVNoZWV0ID0gZnVuY3Rpb24gcmVtb3ZlU3R5bGVTaGVldChzaGVldCkge1xuICAgIHNoZWV0LmRldGFjaCgpO1xuICAgIHNoZWV0cy5yZW1vdmUoc2hlZXQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBydWxlIHdpdGhvdXQgYSBTdHlsZSBTaGVldC5cbiAgICogW0RlcHJlY2F0ZWRdIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5jcmVhdGVSdWxlID0gZnVuY3Rpb24gY3JlYXRlUnVsZSQxKG5hbWUsIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgaWYgKHN0eWxlID09PSB2b2lkIDApIHtcbiAgICAgIHN0eWxlID0ge307XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIC8vIEVuYWJsZSBydWxlIHdpdGhvdXQgbmFtZSBmb3IgaW5saW5lIHN0eWxlcy5cbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVSdWxlKHVuZGVmaW5lZCwgbmFtZSwgc3R5bGUpO1xuICAgIH1cblxuICAgIHZhciBydWxlT3B0aW9ucyA9IF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAganNzOiB0aGlzLFxuICAgICAgUmVuZGVyZXI6IHRoaXMub3B0aW9ucy5SZW5kZXJlclxuICAgIH0pO1xuXG4gICAgaWYgKCFydWxlT3B0aW9ucy5nZW5lcmF0ZUlkKSBydWxlT3B0aW9ucy5nZW5lcmF0ZUlkID0gdGhpcy5nZW5lcmF0ZUlkO1xuICAgIGlmICghcnVsZU9wdGlvbnMuY2xhc3NlcykgcnVsZU9wdGlvbnMuY2xhc3NlcyA9IHt9O1xuICAgIGlmICghcnVsZU9wdGlvbnMua2V5ZnJhbWVzKSBydWxlT3B0aW9ucy5rZXlmcmFtZXMgPSB7fTtcblxuICAgIHZhciBydWxlID0gY3JlYXRlUnVsZShuYW1lLCBzdHlsZSwgcnVsZU9wdGlvbnMpO1xuXG4gICAgaWYgKHJ1bGUpIHRoaXMucGx1Z2lucy5vblByb2Nlc3NSdWxlKHJ1bGUpO1xuICAgIHJldHVybiBydWxlO1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlciBwbHVnaW4uIFBhc3NlZCBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgd2l0aCBhIHJ1bGUgaW5zdGFuY2UuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVzZSA9IGZ1bmN0aW9uIHVzZSgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBsdWdpbnMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBwbHVnaW5zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICBfdGhpcy5wbHVnaW5zLnVzZShwbHVnaW4pO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBKc3M7XG59KCk7XG5cbnZhciBjcmVhdGVKc3MgPSBmdW5jdGlvbiBjcmVhdGVKc3Mob3B0aW9ucykge1xuICByZXR1cm4gbmV3IEpzcyhvcHRpb25zKTtcbn07XG5cbi8qKlxuICogU2hlZXRzTWFuYWdlciBpcyBsaWtlIGEgV2Vha01hcCB3aGljaCBpcyBkZXNpZ25lZCB0byBjb3VudCBTdHlsZVNoZWV0XG4gKiBpbnN0YW5jZXMgYW5kIGF0dGFjaC9kZXRhY2ggYXV0b21hdGljYWxseS5cbiAqIFVzZWQgaW4gcmVhY3QtanNzLlxuICovXG5cbnZhciBTaGVldHNNYW5hZ2VyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2hlZXRzTWFuYWdlcigpIHtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5zaGVldHMgPSBuZXcgV2Vha01hcCgpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNoZWV0c01hbmFnZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5zaGVldHMuZ2V0KGtleSk7XG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnNoZWV0O1xuICB9O1xuXG4gIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQoa2V5LCBzaGVldCkge1xuICAgIGlmICh0aGlzLnNoZWV0cy5oYXMoa2V5KSkgcmV0dXJuO1xuICAgIHRoaXMubGVuZ3RoKys7XG4gICAgdGhpcy5zaGVldHMuc2V0KGtleSwge1xuICAgICAgc2hlZXQ6IHNoZWV0LFxuICAgICAgcmVmczogMFxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5tYW5hZ2UgPSBmdW5jdGlvbiBtYW5hZ2Uoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5zaGVldHMuZ2V0KGtleSk7XG5cbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGlmIChlbnRyeS5yZWZzID09PSAwKSB7XG4gICAgICAgIGVudHJ5LnNoZWV0LmF0dGFjaCgpO1xuICAgICAgfVxuXG4gICAgICBlbnRyeS5yZWZzKys7XG4gICAgICByZXR1cm4gZW50cnkuc2hlZXQ7XG4gICAgfVxuXG4gICAgd2FybmluZyhmYWxzZSwgXCJbSlNTXSBTaGVldHNNYW5hZ2VyOiBjYW4ndCBmaW5kIHNoZWV0IHRvIG1hbmFnZVwiKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuXG4gIF9wcm90by51bm1hbmFnZSA9IGZ1bmN0aW9uIHVubWFuYWdlKGtleSkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuc2hlZXRzLmdldChrZXkpO1xuXG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBpZiAoZW50cnkucmVmcyA+IDApIHtcbiAgICAgICAgZW50cnkucmVmcy0tO1xuICAgICAgICBpZiAoZW50cnkucmVmcyA9PT0gMCkgZW50cnkuc2hlZXQuZGV0YWNoKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsIFwiU2hlZXRzTWFuYWdlcjogY2FuJ3QgZmluZCBzaGVldCB0byB1bm1hbmFnZVwiKTtcbiAgICB9XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKFNoZWV0c01hbmFnZXIsIFt7XG4gICAga2V5OiBcInNpemVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2hlZXRzTWFuYWdlcjtcbn0oKTtcblxuLyoqXG4qIEV4cG9ydCBhIGNvbnN0YW50IGluZGljYXRpbmcgaWYgdGhpcyBicm93c2VyIGhhcyBDU1NUT00gc3VwcG9ydC5cbiogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL3VwZGF0ZXMvMjAxOC8wMy9jc3NvbVxuKi9cbnZhciBoYXNDU1NUT01TdXBwb3J0ID0gdHlwZW9mIENTUyA9PT0gJ29iamVjdCcgJiYgQ1NTICE9IG51bGwgJiYgJ251bWJlcicgaW4gQ1NTO1xuXG4vKipcbiAqIEV4dHJhY3RzIGEgc3R5bGVzIG9iamVjdCB3aXRoIG9ubHkgcHJvcHMgdGhhdCBjb250YWluIGZ1bmN0aW9uIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0RHluYW1pY1N0eWxlcyhzdHlsZXMpIHtcbiAgdmFyIHRvID0gbnVsbDtcblxuICBmb3IgKHZhciBrZXkgaW4gc3R5bGVzKSB7XG4gICAgdmFyIHZhbHVlID0gc3R5bGVzW2tleV07XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKCF0bykgdG8gPSB7fTtcbiAgICAgIHRvW2tleV0gPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFyIGV4dHJhY3RlZCA9IGdldER5bmFtaWNTdHlsZXModmFsdWUpO1xuXG4gICAgICBpZiAoZXh0cmFjdGVkKSB7XG4gICAgICAgIGlmICghdG8pIHRvID0ge307XG4gICAgICAgIHRvW2tleV0gPSBleHRyYWN0ZWQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRvO1xufVxuXG4vKipcbiAqIEEgYmV0dGVyIGFic3RyYWN0aW9uIG92ZXIgQ1NTLlxuICpcbiAqIEBjb3B5cmlnaHQgT2xlZyBJc29uZW4gKFNsb2JvZHNrb2kpIC8gSXNvbmVuIDIwMTQtcHJlc2VudFxuICogQHdlYnNpdGUgaHR0cHM6Ly9naXRodWIuY29tL2Nzc2luanMvanNzXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xudmFyIGluZGV4ID0gY3JlYXRlSnNzKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGluZGV4O1xuZXhwb3J0IHsgUnVsZUxpc3QsIFNoZWV0c01hbmFnZXIsIFNoZWV0c1JlZ2lzdHJ5LCBjcmVhdGVKc3MgYXMgY3JlYXRlLCBjcmVhdGVHZW5lcmF0ZUlkLCBjcmVhdGVSdWxlLCBnZXREeW5hbWljU3R5bGVzLCBoYXNDU1NUT01TdXBwb3J0LCBzaGVldHMsIHRvQ3NzVmFsdWUgfTtcbiJdLCJuYW1lcyI6WyJfZXh0ZW5kcyIsImlzSW5Ccm93c2VyIiwid2FybmluZyIsIl9jcmVhdGVDbGFzcyIsIl9pbmhlcml0c0xvb3NlIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwicGxhaW5PYmplY3RDb25zdHJ1cmN0b3IiLCJjb25zdHJ1Y3RvciIsImNsb25lU3R5bGUiLCJzdHlsZSIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsIm5ld1N0eWxlIiwibmFtZSIsImNyZWF0ZVJ1bGUiLCJkZWNsIiwib3B0aW9ucyIsImpzcyIsImRlY2xDb3B5IiwicnVsZSIsInBsdWdpbnMiLCJvbkNyZWF0ZVJ1bGUiLCJqb2luIiwidmFsdWUiLCJieSIsInJlc3VsdCIsImkiLCJsZW5ndGgiLCJ0b0Nzc1ZhbHVlIiwiY3NzVmFsdWUiLCJnZXRXaGl0ZXNwYWNlU3ltYm9scyIsImZvcm1hdCIsImxpbmVicmVhayIsInNwYWNlIiwiaW5kZW50U3RyIiwic3RyIiwiaW5kZW50IiwiaW5kZXgiLCJ0b0NzcyIsInNlbGVjdG9yIiwiX29wdGlvbnMiLCJfb3B0aW9ucyRpbmRlbnQiLCJmYWxsYmFja3MiLCJJbmZpbml0eSIsIl9nZXRXaGl0ZXNwYWNlU3ltYm9scyIsImZhbGxiYWNrIiwicHJvcCIsIl9wcm9wIiwiX3ZhbHVlIiwiX3Byb3AyIiwiX3ZhbHVlMiIsImFsbG93RW1wdHkiLCJlc2NhcGVSZWdleCIsIm5hdGl2ZUVzY2FwZSIsIkNTUyIsImVzY2FwZSIsInJlcGxhY2UiLCJCYXNlU3R5bGVSdWxlIiwia2V5IiwidHlwZSIsImlzUHJvY2Vzc2VkIiwic2hlZXQiLCJSZW5kZXJlciIsInJlbmRlcmVyIiwiX3Byb3RvIiwicHJvdG90eXBlIiwidW5kZWZpbmVkIiwiZm9yY2UiLCJuZXdWYWx1ZSIsInByb2Nlc3MiLCJvbkNoYW5nZVZhbHVlIiwiaXNFbXB0eSIsImlzRGVmaW5lZCIsInJlbW92ZSIsInJlbmRlcmFibGUiLCJyZW1vdmVQcm9wZXJ0eSIsInNldFByb3BlcnR5IiwiYXR0YWNoZWQiLCJTdHlsZVJ1bGUiLCJfQmFzZVN0eWxlUnVsZSIsIl90aGlzIiwiY2FsbCIsInNjb3BlZCIsImdlbmVyYXRlSWQiLCJzZWxlY3RvclRleHQiLCJpZCIsIl9wcm90bzIiLCJhcHBseVRvIiwianNvbiIsInRvSlNPTiIsInRvU3RyaW5nIiwibGluayIsIm9wdHMiLCJzZXQiLCJoYXNDaGFuZ2VkIiwic2V0U2VsZWN0b3IiLCJyZXBsYWNlUnVsZSIsImdldCIsInBsdWdpblN0eWxlUnVsZSIsInBhcmVudCIsImRlZmF1bHRUb1N0cmluZ09wdGlvbnMiLCJjaGlsZHJlbiIsImF0UmVnRXhwIiwiQ29uZGl0aW9uYWxSdWxlIiwic3R5bGVzIiwiYXRNYXRjaCIsIm1hdGNoIiwiYXQiLCJxdWVyeSIsInJ1bGVzIiwiUnVsZUxpc3QiLCJhZGQiLCJnZXRSdWxlIiwiaW5kZXhPZiIsImFkZFJ1bGUiLCJvblByb2Nlc3NSdWxlIiwibmV3UnVsZSIsImtleVJlZ0V4cCIsInBsdWdpbkNvbmRpdGlvbmFsUnVsZSIsInRlc3QiLCJkZWZhdWx0VG9TdHJpbmdPcHRpb25zJDEiLCJuYW1lUmVnRXhwIiwiS2V5ZnJhbWVzUnVsZSIsImZyYW1lcyIsIm5hbWVNYXRjaCIsImtleVJlZ0V4cCQxIiwicmVmUmVnRXhwIiwiZmluZFJlZmVyZW5jZWRLZXlmcmFtZSIsInZhbCIsImtleWZyYW1lcyIsInJlcGxhY2VSZWYiLCJyZWZLZXlmcmFtZSIsInBsdWdpbktleWZyYW1lc1J1bGUiLCJvblByb2Nlc3NTdHlsZSIsIktleWZyYW1lUnVsZSIsImFwcGx5IiwiYXJndW1lbnRzIiwicGx1Z2luS2V5ZnJhbWVSdWxlIiwiRm9udEZhY2VSdWxlIiwia2V5UmVnRXhwJDIiLCJwbHVnaW5Gb250RmFjZVJ1bGUiLCJWaWV3cG9ydFJ1bGUiLCJwbHVnaW5WaWV3cG9ydFJ1bGUiLCJTaW1wbGVSdWxlIiwia2V5c01hcCIsInBsdWdpblNpbXBsZVJ1bGUiLCJkZWZhdWx0VXBkYXRlT3B0aW9ucyIsImZvcmNlVXBkYXRlT3B0aW9ucyIsInJhdyIsImNvdW50ZXIiLCJjbGFzc2VzIiwicnVsZU9wdGlvbnMiLCJfdGhpcyRvcHRpb25zIiwicmVnaXN0ZXIiLCJzcGxpY2UiLCJvbGRSdWxlIiwib2xkSW5kZXgiLCJuYW1lT3JTZWxlY3RvciIsInVucmVnaXN0ZXIiLCJzbGljZSIsImZvckVhY2giLCJ1cGRhdGUiLCJkYXRhIiwidXBkYXRlT25lIiwiX3RoaXMkb3B0aW9uczIiLCJvblVwZGF0ZSIsIm5leHRWYWx1ZSIsInByZXZWYWx1ZSIsIl9uZXh0VmFsdWUiLCJfcHJldlZhbHVlIiwiY3NzIiwiU3R5bGVTaGVldCIsImRlcGxveWVkIiwiYXR0YWNoIiwiZGVwbG95IiwiZGV0YWNoIiwicXVldWUiLCJwdXNoIiwiaW5zZXJ0UnVsZSIsImRlbGV0ZVJ1bGUiLCJhZGRSdWxlcyIsImFkZGVkIiwiX3RoaXMkcnVsZXMiLCJQbHVnaW5zUmVnaXN0cnkiLCJpbnRlcm5hbCIsImV4dGVybmFsIiwicmVnaXN0cnkiLCJvblByb2Nlc3NTaGVldCIsInByb2Nlc3NlZFZhbHVlIiwidXNlIiwibmV3UGx1Z2luIiwiY29uY2F0IiwicmVkdWNlIiwicGx1Z2luIiwiU2hlZXRzUmVnaXN0cnkiLCJyZXNldCIsIl90ZW1wIiwiX3JlZiIsInNoZWV0cyIsImdsb2JhbFRoaXMkMSIsImdsb2JhbFRoaXMiLCJ3aW5kb3ciLCJNYXRoIiwic2VsZiIsIkZ1bmN0aW9uIiwibnMiLCJtb2R1bGVJZCIsIm1heFJ1bGVzIiwiY3JlYXRlR2VuZXJhdGVJZCIsInJ1bGVDb3VudGVyIiwianNzSWQiLCJwcmVmaXgiLCJjbGFzc05hbWVQcmVmaXgiLCJTdHJpbmciLCJtaW5pZnkiLCJtZW1vaXplIiwiZm4iLCJnZXRQcm9wZXJ0eVZhbHVlIiwiY3NzUnVsZSIsImF0dHJpYnV0ZVN0eWxlTWFwIiwiZXJyIiwiaW5kZXhPZkltcG9ydGFudEZsYWciLCJjc3NWYWx1ZVdpdGhvdXRJbXBvcnRhbnRGbGFnIiwic3Vic3RyIiwiZGVsZXRlIiwibWVzc2FnZSIsImdldEhlYWQiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJmaW5kSGlnaGVyU2hlZXQiLCJpbnNlcnRpb25Qb2ludCIsImZpbmRIaWdoZXN0U2hlZXQiLCJmaW5kQ29tbWVudE5vZGUiLCJ0ZXh0IiwiaGVhZCIsImNoaWxkTm9kZXMiLCJub2RlIiwibm9kZVR5cGUiLCJub2RlVmFsdWUiLCJ0cmltIiwiZmluZFByZXZOb2RlIiwiZWxlbWVudCIsInBhcmVudE5vZGUiLCJuZXh0U2libGluZyIsImNvbW1lbnQiLCJpbnNlcnRTdHlsZSIsIm5leHROb2RlIiwiaW5zZXJ0QmVmb3JlIiwiaW5zZXJ0aW9uUG9pbnRFbGVtZW50IiwiYXBwZW5kQ2hpbGQiLCJnZXROb25jZSIsImdldEF0dHJpYnV0ZSIsIl9pbnNlcnRSdWxlIiwiY29udGFpbmVyIiwiYXBwZW5kUnVsZSIsImNzc1J1bGVzIiwiZ2V0VmFsaWRSdWxlSW5zZXJ0aW9uSW5kZXgiLCJtYXhJbmRleCIsImNyZWF0ZVN0eWxlIiwiZWwiLCJjcmVhdGVFbGVtZW50IiwidGV4dENvbnRlbnQiLCJEb21SZW5kZXJlciIsImhhc0luc2VydGVkUnVsZXMiLCJtZWRpYSIsIm1ldGEiLCJzZXRBdHRyaWJ1dGUiLCJub25jZSIsIkJvb2xlYW4iLCJyZW1vdmVDaGlsZCIsImluc2VydFJ1bGVzIiwibmF0aXZlUGFyZW50IiwibGF0ZXN0TmF0aXZlUGFyZW50IiwiX2luc2VydGlvbkluZGV4IiwicmVmQ3NzUnVsZSIsInJ1bGVTdHIiLCJpbnNlcnRpb25JbmRleCIsIm5hdGl2ZVJ1bGUiLCJnZXRSdWxlcyIsImluc3RhbmNlQ291bnRlciIsIkpzcyIsInZlcnNpb24iLCJzZXR1cCIsImNyZWF0ZVN0eWxlU2hlZXQiLCJyZW1vdmVTdHlsZVNoZWV0IiwiY3JlYXRlUnVsZSQxIiwiX2xlbiIsIl9rZXkiLCJjcmVhdGVKc3MiLCJTaGVldHNNYW5hZ2VyIiwiV2Vha01hcCIsImVudHJ5IiwiaGFzIiwicmVmcyIsIm1hbmFnZSIsInVubWFuYWdlIiwiaGFzQ1NTVE9NU3VwcG9ydCIsImdldER5bmFtaWNTdHlsZXMiLCJ0byIsImV4dHJhY3RlZCIsImNyZWF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jss/dist/jss.esm.js\n");

/***/ })

};
;